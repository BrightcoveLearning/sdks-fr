<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>Référence Brightcove Native Player pour iOS</title>

	<link rel="stylesheet" href="css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title"> <a href="index.html">Lecteur natif Brightcove pour iOS </a> </h1>

			<p id="developer-home">
				Brightcove<a href="index.html"></a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="hierarchy.html">Hiérarchie</a></li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview-contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">Référence Brightcove Native Player pour iOS</h1>

					
					<div class="section section-overview index-overview">
						
						
						<h1>Kit de développement logiciel Brightcove Player pour iOS, version 6.9.0.1697</h1> <h1>Table des matières</h1>

<ol>
<li><a href="#Requirements">Conditions</a></li>
<li><a href="#SupportedPlatforms">Plateformes prises en charge</a></li>
<li><a href="#Noteworthy">Remarquable</a></li>
<li><a href="#FairPlay">Fair-play</a></li>
<li><a href="#SidecarSubtitles">Sous-titres Sidecar</a></li>
<li><a href="#OfflinePlayback">Lecture hors ligne</a></li>
<li>Installation<a href="#Installation"></a></li>
<li>CocoaPods<a href="#CocoaPods"></a></li>
<li><a href="#ManualInstallation">Installation manuelle</a></li>
<li><a href="#Imports">Importations</a></li>
<li><a href="#QuickStart">Démarrage rapide</a></li>
<li><a href="#PlayerUI">Contrôles PlayerUI intégrés pour iOS</a></li>
<li><a href="#TVPlayer">Commandes de lecteur TV intégrées pour tvOS</a></li>
<li>AirPlay<a href="#AirPlay"></a></li>
<li><a href="#Video360">Vidéo 360</a></li>
<li><a href="#ArchitecturalOverview">Aperçu architectural</a></li>
<li><a href="#PlayPauseSeek">Lecture, pause et recherche</a></li>
<li><a href="#PreloadingVideos">Préchargement de vidéos</a></li>
<li><a href="#SourceSelection">Sélection de la source (HLS, MP4, HTTP/HTTPS)</a></li>
<li><a href="#PreferredBitrate">Définition d'un débit binaire préféré</a></li>
<li><a href="#PlaybackInformation">Obtention d'informations sur le contenu et la lecture des annonces</a></li>
<li><a href="#HandlingNetworkInterruptionsAndSlowdowns">Gestion des interruptions et des ralentissements du réseau</a></li>
<li><a href="#Subclassing">Sous-classement</a></li>
<li><a href="#Values">Valeurs</a></li>
<li><a href="#PlaybackService">Récupération des actifs Brightcove à l'aide du service de lecture</a></li>
<li><a href="#ViewStrategy">Voir la stratégie</a></li>
<li><a href="#BackgroundVideo">Lecture de vidéo en arrière-plan</a></li>
<li><a href="#PIP">Image dans l'image</a></li>
<li><a href="#ThumbnailSeeking">Recherche de vignettes</a></li>
<li><a href="#TrackingErrors">Erreurs de suivi</a></li>
<li><a href="#CombiningPlugins">Combiner des plugins</a></li>
<li><a href="#BufferOptimization">Optimisation de la mémoire tampon</a></li>
<li><a href="#AVPlayerViewController">Utilisation d'un AVPlayerViewController avec un BCOVPlaybackController</a></li>
<li><a href="#PlaybackAuthorizationService">Service d'autorisation de lecture</a></li>
<li><a href="#VoiceOver">Assistance VoiceOver</a></li>
<li><a href="#ChinaDelivery">Livraison en Chine</a></li>
<li><a href="#AVAudioSessionConfig">Configuration d'AVAudioSession</a></li>
<li><a href="#FAQ">Questions fréquemment posées</a></li>
<li><a href="#Support">Soutien</a></li>
</ol>


<h1>Conditions <a name="Requirements"></a></h1>

<ul>
<li>Xcode 11.0+</li>
<li>ARC</li>
</ul>


<h1>Plateformes prises en charge <a name="SupportedPlatforms"></a></h1>

<p>Brightcove fournit un support actif pour le dernier SDK iOS sur la dernière version publique des versions iOS suivantes :</p>

<ul>
<li>iOS 12, 13 et 14</li>
<li>tvOS 12, 13 et 14</li>
</ul>


<p>Brightcove fournit une prise en charge passive des versions iOS suivantes :</p>

<ul>
<li>iOS 11.4.1</li>
<li>tvOS 11.4.1</li>
</ul>


<p>Le Core SDK est localisé pour l'arabe (ar), l'anglais (en), le français (fr), l'allemand (de), le japonais (ja), le coréen (ko), l'espagnol (es), le chinois simplifié (zh-Hans) et le traditionnel Chinois (zh-Hant). Pour bénéficier d'une localisation, votre application doit également être localisée pour la même langue et les mêmes paramètres régionaux.</p>

<h1>Remarquable <a name="Noteworthy"></a></h1>

<p>Tous les composants SDK - les frameworks de base et de plugin - sont publiés avec le même numéro de version. Lors de la mise à niveau d'un seul composant, mettez à niveau tous les composants vers la même version.</p>

<p><strong>Noms CocoaPods Podspec (depuis la version 6.8.1)</strong></p>

<p>La version 6.8.1 du Brightcove Player SDK met à jour le <code>Brightcove-Player-FreeWheel</code> et <code>Brightcove-Player-Omniture</code> podspecs pour installer la version dynamique de <code>BrightcovePlayerSDK</code>. UNE <code>-statique</code> podspec est maintenant disponible pour chaque plugin qui installera la version statique de <code>BrightcovePlayerSDK</code> ainsi que la version statique du framework de plugin lui-même. S'il n'y a pas de version statique d'un plugin, la version dynamique sera installée avec la version statique de <code>BrightcovePlayerSDK</code>.</p>

<table>
<thead>
<tr>
<th>Nom du podspec  </th>
<th>  Type de cadre  </th>
<th>  Dépendance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Brightcove-Player-Core </td>
<td> dynamique </td>
<td> -</td>
</tr>
<tr>
<td>Brightcove-Player-Core-statique </td>
<td> statique  </td>
<td> -</td>
</tr>
<tr>
<td>Brightcove-Player-FreeWheel </td>
<td> statique </td>
<td> Brightcove-Player-Core pour iOS,<br/>Brightcove-Player-Core pour tvOS</td>
</tr>
<tr>
<td>Brightcove-Player-FreeWheel-static </td>
<td> statique </td>
<td> Brightcove-Player-Core-static pour iOS,<br/>Brightcove-Player-Core pour tvOS</td>
</tr>
<tr>
<td>Brightcove-Player-GoogleCast </td>
<td> statique </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-GoogleCast-statique </td>
<td> statique </td>
<td> Brightcove-Player-Core-statique</td>
</tr>
<tr>
<td>Brightcove-Player-IMA </td>
<td> dynamique </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-IMA-statique </td>
<td> dynamique </td>
<td> Brightcove-Player-Core-statique</td>
</tr>
<tr>
<td>Brightcove-Player-Omniture </td>
<td> statique </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-Omniture-statique </td>
<td> statique </td>
<td> Brightcove-Player-Core-statique</td>
</tr>
<tr>
<td>Brightcove-Player-Pulse </td>
<td> dynamique </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-Pulse-statique </td>
<td> dynamique </td>
<td> Brightcove-Player-Core-statique</td>
</tr>
<tr>
<td>Brightcove-Player-SSAI </td>
<td> dynamique </td>
<td> Brightcove-Player-Core</td>
</tr>
<tr>
<td>Brightcove-Player-SSAI-statique </td>
<td> statique </td>
<td> Brightcove-Player-Core-statique</td>
</tr>
</tbody>
</table>


<h2>Fair-play <a name="FairPlay"></a></h2>

<p>La prise en charge de la lecture de vidéos protégées par FairPlay est intégrée au noyau <em>BrightcovePlayerSDK</em> cadre. Se référer au <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/FairPlay.md">Guide du fair-play</a> pour plus de détails sur l'utilisation de FairPlay avec le Brightcove Native Player SDK.</p>

<h2>Sous-titres Sidecar <a name="SidecarSubtitles"></a></h2>

<p>La prise en charge des sous-titres Sidecar est intégrée au noyau <em>BrightcovePlayerSDK</em> cadre. Pour plus de détails sur l'utilisation des sous-titres Sidecar avec le Brightcove Native Player SDK, reportez-vous au <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/SidecarSubtitles.md">Guide des sous-titres Sidecar</a>.</p>

<h2>Téléchargements de vidéos et lecture hors ligne <a name="OfflinePlayback"></a></h2>

<p>Depuis la version 6.0.0, le Brightcove Native Player SDK vous permet de télécharger des vidéos HLS, y compris celles protégées par le cryptage FairPlay, pour une lecture ultérieure, que ce soit en ligne ou hors ligne. Référez-vous au développeur de l'application&rsquo;s guide pour plus de détails:</p>

<p><a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/OfflinePlayback.md">Développeur d'applications iOS&rsquo;s Guide de téléchargement de vidéos et de lecture hors ligne avec FairPlay</a></p>

<h1>Installation <a name="Installation"></a></h1>

<p>Le Brightcove Player SDK fournit deux packages d'installation pour iOS, un framework de bibliothèque statique et un framework dynamique. Le déploiement est pris en charge sur iOS 11 et versions ultérieures.</p>

<p>Le Brightcove Player SDK fournit un cadre dynamique pour prendre en charge tvOS 11.0 et supérieur.</p>

<h2>CocoaPods <a name="CocoaPods"></a></h2>

<p>Vous pouvez utiliser <a href="https://cocoapods.org">CocoaPods</a> pour ajouter le Brightcove Player SDK à votre projet. Vous pouvez trouver les dernières <code>Brightcove-Player-Core</code> podspec <a href="https://github.com/brightcove/BrightcoveSpecs/tree/master/Brightcove-Player-Core">ici</a>. Le podspec prend en charge à la fois iOS et tvOS. CocoaPods 1.0 ou plus récent est requis et la dernière version est recommandée.</p>

<p>Lorsque vous utilisez Brightcove CocoaPods dans votre projet, ajoutez <code>la source '</code>https://github.com/brightcove/BrightcoveSpecs.git'<code></code> au début de votre Podfile.</p>

<p>Spécification du pod par défaut <code>Brightcove-Player-Core</code> installera le framework de bibliothèque dynamique. Pour installer le framework statique, ajoutez <code>-statique</code> comme ça: <code>pod 'Brightcove-Player-Core-static'</code>.</p>

<p>Exemple de cadre dynamique :</p>

<pre><code>source 'https://github.com/CocoaPods/Specs' source 'https://github.com/brightcove/BrightcoveSpecs.git' plateforme :ios, '11.0' use_frameworks ! cible 'MyVideoPlayer' do pod 'Brightcove-Player-Core' finir </code></pre>

<p>Exemple de cadre statique :</p>

<pre><code>source 'https://github.com/CocoaPods/Specs' source 'https://github.com/brightcove/BrightcoveSpecs.git' plateforme :ios, '11.0' use_frameworks ! cible 'MyVideoPlayer' do pod 'Brightcove-Player-Core-static' finir </code></pre>

<p>Lors de la mise à jour de votre installation, il&rsquo;C'est une bonne idée d'actualiser la copie locale de votre référentiel BrightcoveSpecs afin d'avoir les dernières podspecs localement, tout comme vous mettriez à jour votre référentiel maître CococaPods. Généralement si vous exécutez <code>mise à jour du pod</code> dans Terminal, cela se produira automatiquement, ou vous pouvez également mettre à jour explicitement avec <code>mise à jour du dépôt de pod</code>.</p>

<h2>Installation manuelle <a name="ManualInstallation"></a></h2>

<p>Pour ajouter manuellement le Brightcove Player SDK à votre projet :</p>

<ol>
<li>Téléchargez la dernière version zippée de notre <a href="https://github.com/brightcove/brightcove-player-sdk-ios/releases">page de publication</a>.</li>
<li>Ajouter <code>BrightcovePlayerSDK.framework</code> à votre projet. Assurez-vous d'utiliser la version correspondant à votre cible, iOS ou tvOS.</li>
<li>Sur le &ldquo;Paramètres de construction&rdquo; de l'onglet cible de votre application, assurez-vous que le &ldquo;Chemins de recherche du framework&rdquo; inclure le chemin d'accès au cadre. Cela aurait dû être fait automatiquement à moins que le framework ne soit stocké dans un répertoire racine différent de celui de votre projet.</li>
<li><p>Sur le &ldquo;Général&rdquo; de l'onglet cible de votre application, ajoutez ce qui suit à la &ldquo;Frameworks, bibliothèques, contenu intégré&rdquo; section:</p>

<ul>
<li>BrightcovePlayerSDK.framework<code></code></li>
</ul>
</li>
<li>(<strong>Cadre dynamique</strong> uniquement) sur le &ldquo;Général&rdquo; onglet de votre application cible, ajoutez &lsquo;BrightcovePlayerSDK.framework&rsquo; à la &ldquo;Binaires embarqués&rdquo; section.</li>
<li>(<strong>Cadre dynamique</strong> uniquement) sur le &ldquo;Phases de construction&rdquo; onglet, ajoutez un &ldquo;Script de lancement&rdquo; phase avec la commande <code>coup ${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/BrightcovePlayerSDK.framework/strip-frameworks.sh</code>. Vérifier &ldquo;Exécuter le script uniquement lors de l'installation&rdquo;. Cela supprimera les architectures inutiles de la construction, ce qui est important pour la soumission App Store.</li>
<li>(<strong>Cadre statique</strong> uniquement) sur le &ldquo;Paramètres de construction&rdquo; onglet de votre application cible, ajoutez <code>-ObjC</code> à la &ldquo;Autres indicateurs de liens&rdquo; paramètre de construction.</li>
<li>(<strong>Cadre statique</strong> uniquement) Localisez le fichier <code>bcovpuiiconfont.ttf</code> au sein de la <code>BrightcovePlayerSDK.framework</code> bundle et faites-le glisser directement dans votre liste de projets afin que le fichier de police devienne une partie de votre application. Après avoir fait glisser le fichier, assurez-vous de l'ajouter à votre application&rsquo;s build target lorsque vous y êtes invité. Une fois votre application créée, le fichier de police doit résider dans le bundle d'applications au même niveau que l'application&rsquo;s Fichier Info.plist. Le fichier de police fournit certains des <code>BrightcovePlayerUI</code> éléments d'interface, mais il n'a pas besoin d'être répertorié dans le plist lui-même.</li>
</ol>


<p>Pour référence, voici tous les composants du SDK et les URL correspondantes pour vous aider à localiser et télécharger les dernières versions :</p>

<table>
<thead>
<tr>
<th>Composant  </th>
<th> URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>Brightcove-Player-Core </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-FreeWheel </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-fw/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-fw/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-IMA </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-ima/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-ima/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-Omniture </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-omniture/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-omniture/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-Pulse </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-pulse/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-pulse/releases"></a></td>
</tr>
<tr>
<td>Brightcove-Player-SSAI </td>
<td> https://github.com/brightcove/brightcove-player-sdk-ios-ssai/releases<a href="https://github.com/brightcove/brightcove-player-sdk-ios-ssai/releases"></a></td>
</tr>
</tbody>
</table>


<h2>Importations <a name="Imports"></a></h2>

<p>Le Brightcove Player SDK pour iOS peut être importé dans le code de différentes manières :</p>

<pre><code>@import BrightcovePlayerSDK ; </code></pre>

<pre><code>#import &lt;BrightcovePlayerSDK/BrightcovePlayerSDK.h&gt; </code></pre>

<pre><code>#import &lt;BrightcovePlayerSDK/[specific-class].h&gt; </code></pre>

<h1>Démarrage rapide <a name="QuickStart"></a></h1>

<p>Lecture de vidéo avec le Brightcove Player SDK pour iOS :</p>

<pre><code>// ** Personnalisez ces valeurs avec vos propres informations de compte ** NSString statique * const kViewControllerPlaybackServicePolicyKey = @"..."; NSString statique * const kViewControllerAccountID = @"..."; NSString statique * const kViewControllerVideoID = @"..."; BCOVPlayerSDKManager *manager = [BCOVPlayerSDKManagersharedManager] ; id&lt;BCOVPlaybackController&gt; contrôleur = [gestionnaire createPlaybackController]; self.controller = contrôleur; // stocke ceci dans une propriété forte [self.view addSubview:controller.view] ; BCOVPlaybackService *service = [[BCOVPlaybackService alloc] initWithAccountId:kAccountId policyKey:kPlaybackServicePolicyKey]; [service findVideoWithVideoID : paramètres kViewControllerVideoID : achèvement nul : ^(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error) { [controller setVideos:@[ video ]]; [controller play]; } ; </code></pre>

<p>Vous devez éviter que le contrôleur ne soit automatiquement libéré à la fin de la méthode. Une manière courante de procéder consiste à stocker une référence au contrôleur dans une variable d'instance forte.</p>

<h1>Contrôles PlayerUI intégrés <a name="PlayerUI"></a></h1>

<p>Depuis la version 5.1.0, Brightcove PlayerUI est entièrement intégré au framework Core SDK. PlayerUI fournit un ensemble complet de commandes pour la lecture et la publicité, dès la sortie de la boîte.</p>

<p>Le PlayerUI est rapide à configurer, affiche les commandes publicitaires pour SSAI, Pulse et FreeWheel, et peut être personnalisé en créant vos propres mises en page.</p>

<h2>Configuration des contrôles PlayerUI</h2>

<p>Suivez les instructions ci-dessous pour configurer les commandes PlayerUI.</p>

<p>Créez une propriété dans votre UIViewController pour garder une trace du <a href="Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a>. Les <a href="Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a> contiendra à la fois le contrôleur de lecture&rsquo;la vue s et la vue des commandes.</p>

<pre><code>// Vue du joueur de PlayerUI @property (non atomique) BCOVPUIPlayerView *playerView; </code></pre>

<p>Créer le <a href="Classes/BCOVPUIBasicControlView.html">BCOVPUIBasicControlView</a> , puis le <a href="Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a>. C'est ici que nous associons le Playback Controller (et donc toutes les vidéos qu'il lit) aux commandes.</p>

<pre><code>// Créer et configurer la vue de contrôle. BCOVPUIBasicControlView *controlView = [BCOVPUIBasicControlView basicControlViewWithVODLayout]; self.playerView = [[BCOVPUIPlayerView alloc] initWithPlaybackController:self.playbackController options:nil controlView:controlView]; // Ajoutez BCOVPUIPlayerView à votre vue vidéo. [self.videoView addSubview:self.playerView] ; </code></pre>

<p>Tu&rsquo;Vous aurez besoin de configurer la mise en page pour la vue du joueur, vous pouvez le faire avec la mise en page automatique ou l'ancienne approche Springs &amp; Struts.</p>

<p><strong>Ressorts et jambes de force :</strong></p>

<p>Définissez la vue du lecteur pour qu'elle corresponde au conteneur vidéo de votre mise en page (<code>vidéoVoir</code> ) lorsqu'il est redimensionné.</p>

<pre><code>self.playerView.frame = self.videoView.bounds; self.playerView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth; </code></pre>

<p><strong>Mise en page automatique</strong></p>

<p>Met le <code>translateAutoresizingMaskIntoConstraints</code> au <a href="Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a> à <code>NON</code>.</p>

<pre><code>self.playerView.translatesAutoresizingMaskIntoConstraints = NO; </code></pre>

<p>Ajoutez ensuite les contraintes pour la mise en page ; réglage des ancrages supérieur, droit, gauche et inférieur de votre <a href="Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a> égal à celui de <code>vidéoVoir</code></p>

<pre><code>[NSLayoutConstraint activateConstraints:@[ [self.playerView.topAnchor ContrainteEqualToAnchor:self.videoView.topAnchor], [self.playerView.rightAnchor ContrainteEqualToAnchor:self.videoView.rightAnchor], [self.playerView.leftAnchor ContrainteEqualToAnchor:self]videoView.leftAnchor , [self.playerView.bottomAnchor ContrainteEqualToAnchor:self.videoView.bottomAnchor], ]] ; </code></pre>

<p><strong>Rappel:</strong> Le PlayerUI utilise un petit fichier de police pour divers graphiques. Si vous installez le framework statique et n'utilisez pas CocoaPods, assurez-vous d'ajouter le fichier <code>bcovpuiiconfont.ttf</code> du <code>BrightcovePlayerSDK.framework</code> bundle directement dans votre liste de projets afin que le fichier de police soit copié dans le bundle d'applications</p>

<h2>BCOVPUIPlayerViewOptions<a href="Classes/BCOVPUIPlayerViewOptions.html"></a></h2>

<p>Les <a href="Classes/BCOVPUIPlayerViewOptions.html"><code>BCOVPUIPlayerViewOptions</code></a> La classe vous permet de personnaliser certains comportements de BCOVPlayerUI lors de l'initialisation. Vous pouvez personnaliser les éléments suivants :</p>

<ul>
<li><code>jumpBackInterval</code> Le temps en secondes que le lecteur recherchera en arrière lorsque le bouton de retour en arrière est enfoncé.</li>
<li><code>masquerIntervalleContrôles</code> Le temps en secondes après le dernier événement tactile, avant que les commandes ne soient masquées.</li>
<li><code>masquerContrôlesAnimationDurée</code> Le temps en secondes qu'il faut pour que les contrôles s'animent jusqu'à ce qu'ils soient masqués.</li>
<li><code>showControlsAnimationDurée</code> Le temps en secondes nécessaire pour que les contrôles s'animent et deviennent visibles.</li>
<li><code>learnMoreButtonBrowserStyle</code> Paramètre qui détermine si le fait d'appuyer sur le &ldquo;Apprendre encore plus&rdquo; sur une annonce affichera le lien de clic dans un navigateur externe (paramètre par défaut) ou un navigateur interne.</li>
<li><code>présentationViewController</code> La sous-classe UIViewController à utiliser pour présenter d'autres contrôleurs de vue (comme le contrôleur de vue de sélection de sous-titres codés).</li>
<li><code>AutomaticControlTypeSelection</code> Que vous vouliez ou non le <code>BCOVPUIPlayerView</code> choisir un <code>BCOVPUIBasicControlView</code> tapez automatiquement en fonction du type de vidéo. Si la vidéo est en VOD alors <code>basicControlViewWithVODLayout</code> sera utilisé, pour vivre <code>basicControlViewWithLiveLayout</code> et pour le DVR en direct <code>basicControlViewWithLiveDVRlayout</code>. Lorsque cette valeur est définie sur <code>OUI</code> les <code>BCOVPUIBasicControlView</code> propriété passée dans le <code>BCOVPUIPlayerView</code> l'initialiseur sera ignoré.</li>
</ul>


<p>Les options peuvent être définies à l'aide de la méthode suivante :</p>

<pre><code> BCOVPlayerSDKManager *manager = [BCOVPlayerSDKManagersharedManager] ; id&lt;BCOVPlaybackController&gt; contrôleur = [gestionnaire createPlaybackController]; BCOVPUIPlayerViewOptions *options = [[BCOVPUIPlayerViewOptions alloc] init]; options.jumpBackInterval = 5; BCOVPUIPlayerView *playerView = [[BCOVPUIPlayerView alloc] initWithPlaybackController:playbackController options:options]; </code></pre>

<h2>Dispositions fournies</h2>

<p>Trois dispositions sont fournies pour prendre en charge différents types de vidéo :</p>

<ul>
<li><p><code></code>BCOVPUIControlLayout<code> basicVODControlLayout</code> est une disposition de base pour les flux vidéo à la demande généraux.</p></li>
<li><p><code></code>BCOVPUIControlLayout<code> basicLiveControlLayout</code> est une mise en page pour la vidéo en direct.</p></li>
<li><p><code></code>BCOVPUIControlLayout<code> basicLiveDVRControlLayout</code> est une disposition pour les flux vidéo en direct avec des commandes DVR.</p></li>
</ul>


<p>Vous définissez généralement une nouvelle mise en page immédiatement après votre <a href="Classes/BCOVPUIPlayerView.html"><code>BCOVPUIPlayerView</code></a> est créé, mais vous pouvez également définir une nouvelle mise en page à tout moment. Par exemple, vous pouvez définir une nouvelle mise en page VOD comme celle-ci :</p>

<pre><code>playerView.controlsView.layout = [BCOVPUIControlLayout basicVODControlLayout] </code></pre>

<h2>Dispositions personnalisées</h2>

<p>En plus des mises en page par défaut, vous pouvez créer vos propres mises en page hautement personnalisées en instanciant un nouveau <a href="Classes/BCOVPUIControlLayout.html"><code>BCOVPUIControlLayout</code></a> avec votre propre conception.</p>

<ol>
<li><p>Tout d'abord, créez les contrôles qui iront dans votre mise en page en utilisant <a href="Classes/BCOVPUIBasicControlView.html"><code>BCOVPUIBasicControlView</code></a> layoutViewWithControlFromTag:width:elasticity:<code>. Chaque contrôle est conditionné dans un</code><a href="Classes/BCOVPUILayoutView.html"><code>BCOVPUILayoutView</code></a> qui détermine l'espacement des commandes.</p></li>
<li><p>Vous pouvez définir le <code>largeur</code> de chaque vue de mise en page à la largeur par défaut (qui est basée sur le type de contrôle), ou vous pouvez spécifier votre propre largeur.</p></li>
<li><p>Utilisez le <code>élasticité</code> argument pour déterminer de combien la vue de disposition contenant le contrôle redimensionne sa largeur pour remplir la barre de contrôle.</p>

<ul>
<li>Une élasticité de zéro signifie que la taille de la vue de mise en page sera fixe.</li>
<li>Une valeur d'élasticité supérieure à zéro détermine de combien la vue de mise en page s'agrandira pour remplir l'espace disponible par rapport à toutes les autres vues élastiques dans cette barre de contrôle. Une vue de mise en page avec une valeur d'élasticité de 2,0 croîtra deux fois plus vite qu'une vue de mise en page avec une valeur d'élasticité de 1,0. En règle générale, une rangée de vues de mise en page aura au moins un contrôle avec une élasticité supérieure à zéro.</li>
</ul>
</li>
</ol>


<p>Voici des exemples de création de divers contrôles de base.</p>

<pre><code>// Créer diverses vues de mise en page standard // Bouton de lecture/pause standard BCOVPUILayoutView *playbackLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagButtonPlayback width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Bouton de retour standard BCOVPUILayoutView *jumpBackButtonLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagButtonJumpBack width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Indicateur d'heure actuelle BCOVPUILayoutView *currentTimeLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagLabelCurrentTime width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Séparateur de temps - généralement le '/' caractère BCOVPUILayoutView *timeSeparatorLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagLabelTimeSeparator width:kBCOVPUILayoutUseDefaultValue elasticity:0.0] ; // Étiquette de durée vidéo BCOVPUILayoutView *durationLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagLabelDuration width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Barre de défilement utilisée pour parcourir la vidéo // L'élasticité est définie sur 1 afin qu'elle puisse être redimensionnée pour remplir l'espace disponible BCOVPUILayoutView *progressLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagSliderProgress width:kBCOVPUILayoutUseDefaultValue elasticity:1.0]; // Bouton de sous-titres // Ce bouton est initialement masqué ('supprimé'), et sera affiché // si des sous-titres ou des pistes audio sont disponibles. BCOVPUILayoutView *closedCaptionLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagButtonClosedCaption width:kBCOVPUILayoutUseDefaultValue elasticity:0.0] ; closedCaptionLayoutView.removed = OUI; // Le bouton plein écran BCOVPUILayoutView *screenModeLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagButtonScreenMode width:kBCOVPUILayoutUseDefaultValue elasticity:0.0]; // Bouton AirPlay // Ce bouton est initialement masqué ('supprimé'), et sera affiché // si des appareils AirPlay sont disponibles. BCOVPUILayoutView *externalRouteLayoutView = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewExternalRoute width:kBCOVPUILayoutUseDefaultValue elasticity:0.0] ; externalRouteLayoutView.removed = OUI; // Vue vide - utilisée comme espaceur BCOVPUILayoutView *spacerLayoutView1 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty width:1.0 elasticity:1.0]; // Vue vide - utilisée comme espaceur BCOVPUILayoutView *spacerLayoutView2 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty width:1.0 elasticity:1.0]; // Vue vide - aura un UIImageView personnalisé ajouté en tant que sous-vue BCOVPUILayoutView *logoLayoutView1 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty width:80.0 elasticity:1.0]; // Vue vide - aura un UIImageView personnalisé ajouté en tant que sous-vue BCOVPUILayoutView *logoLayoutView2 = [BCOVPUIBasicControlView layoutViewWithControlFromTag:BCOVPUIViewTagViewEmpty width:36.0 elasticity:0.0]; </code></pre>

<p>Notez que vous pouvez également créer une vue de mise en page vide, dans laquelle vous pouvez placer votre propre vue (logo, champ, rien, etc.). Ce code montre comment placer un <code>UIImage</code> logo à l'intérieur du logoLayoutView1 que nous avons créé ci-dessus.</p>

<pre><code>// Crée une image de logo dans une vue d'image pour l'affichage dans la barre de contrôle. UIImage *logoImage1 = [UIImage imageNamed:@"myLogo"]; UIImageView *logoImageView1 = [[UIImageView alloc] initWithImage:logoImage1]; logoImageView1.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; logoImageView1.contentMode = UIViewContentModeScaleAspectFit; logoImageView1.frame = logoLayoutView1.frame; // Ajouter une vue d'image à notre vue de mise en page vide. [logoLayoutView1 addSubview:logoImageView1] ; </code></pre>

<p>Maintenant qu'il existe différents contrôles regroupés dans des vues de mise en page, ils sont ordonnés en tableaux, chacun représentant une seule ligne de contrôles, c'est-à-dire une barre de contrôle. Notez que vous pouvez avoir différentes dispositions pour les orientations portrait et paysage, vous devrez donc généralement configurer deux tableaux différents de barres de contrôle.</p>

<p>Dans la disposition standard pour l'orientation paysage, les contrôles sont organisés dans un seul tableau, puis ce tableau est stocké dans un autre tableau représentant l'ensemble des contrôles.</p>

<pre><code> NSArray *standardLayoutLine1 = @[ playbackLayoutView, jumpBackButtonLayoutView, currentTimeLayoutView, timeSeparatorLayoutView, durationLayoutView, progressLayoutView, spacerLayoutView1, logoLayoutView1, spacerLayoutView2, closedCaptionLayoutView, screenModeLayoutView, externalRouteLayout; NSArray *standardLayoutLines = @[ standardLayoutLine1 ]; </code></pre>

<p>Dans la disposition compacte pour l'orientation portrait, deux tableaux de contrôles sont créés, un pour chaque ligne. Ces tableaux sont regroupés dans un autre tableau représentant la disposition compacte.</p>

<p>Notez que les mêmes objets sont utilisés pour la plupart des contrôles dans chaque disposition. Lorsque cela est fait et que vous basculez entre les orientations portrait et paysage, l'objet sera déplacé vers sa nouvelle position à l'aide d'une animation fluide.</p>

<pre><code> NSArray *compactLayoutLine1 = @[ currentTimeLayoutView, progressLayoutView, durationLayoutView ]; NSArray *compactLayoutLine2 = @[ playbackLayoutView, jumpBackButtonLayoutView, spacerLayoutView1, closedCaptionLayoutView, screenModeLayoutView, externalRouteLayoutView, logoLayoutView2 ]; NSArray *compactLayoutLines = @[ compactLayoutLine1, compactLayoutLine2 ]; </code></pre>

<p>Enfin, maintenant qu'il existe deux configurations de mise en page (une pour la pleine largeur et une pour la largeur compacte), vous pouvez créer un nouveau <a href="Classes/BCOVPUIControlLayout.html"><code>BCOVPUIControlLayout</code></a> objet, et placez-le dans le lecteur&rsquo;s vue de contrôle.</p>

<pre><code> BCOVPUIControlLayout *customLayout = [[BCOVPUIControlLayout alloc] initWithStandardControls:standardLayoutLines compactControls:compactLayoutLines]; playerView.controlsView.layout = customLayout; </code></pre>

<p>Si vous avez des contrôles que vous devez afficher ou masquer fréquemment, vous pouvez définir le <code>supprimé</code> propriété sur ce contrôle&rsquo;s vue mise en page. Lorsque vous avez modifié vos commandes, appelez <code>setNeedsLayout</code> sur le lecteurVoir&rsquo;s controlView :</p>

<pre><code> logoLayoutView1.removed = OUI; [playerView.controlsView setNeedsLayout] ; </code></pre>

<p>Vous pouvez également personnaliser plusieurs <a href="Classes/BCOVPUIControlLayout.html"><code>BCOVPUIControlLayout</code></a> Propriétés:</p>

<ul>
<li><code>controlBarHeight</code> définit la taille de chaque ligne de contrôles.</li>
<li><code>horizontalItemSpacing</code> définit l'espacement entre chaque <a href="Classes/BCOVPUILayoutView.html"><code>BCOVPUILayoutView</code></a> dans chaque barre de contrôle.</li>
<li><code>compactLayoutLargeurMaximum</code> détermine quel ensemble de contrôles est utilisé. Si la vue de contrôle est plus petite que <code>compactLayoutLargeurMaximum</code> , le jeu de commandes compact sera utilisé, sinon les commandes standard seront utilisées.</li>
</ul>


<p>Pour modifier l'ensemble des contrôles affichés, vous devez créer et installer un nouveau <a href="Classes/BCOVPUIControlLayout.html"><code>BCOVPUIControlLayout</code></a>. De nouveaux contrôles peuvent être installés à tout moment.</p>

<h2>Plus d'exemples de personnalisation</h2>

<p>Pour plus d'exemples de personnalisation de PlayerUI, vous pouvez consulter l'exemple de code dans le dossier PlayerUI du référentiel BrightcoveOS GitHub :</p>

<p>[https://github.com/BrightcoveOS/ios-player-samples](https://github.com/BrightcoveOS/ios-player-samples)<a href="https://github.com/BrightcoveOS/ios-player-samples"></a></p>

<h1>Commandes de lecteur TV intégrées pour tvOS <a name="TVPlayer"></a></h1>

<p>Le Brightcove Native Player SDK comprend des commandes intégrées pour la lecture dans tvOS sur Apple TV. Pour plus de détails sur l'utilisation de l'interface utilisateur TV Player intégrée avec le Brightcove Native Player SDK, consultez notre <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/TVPlayer.md">Guide du lecteur TV</a>.</p>

<h1>AirPlay <a name="AirPlay"></a></h1>

<p>Activez la fonctionnalité AirPlay en définissant le <code>setAutoriseExterneLecture</code> propriété sur votre <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> à <code>vrai</code>. Le bouton AirPlay s'affichera dans les commandes de lecture si des appareils AirPlay sont trouvés sur votre réseau.</p>

<p>Actuellement, IMA est le seul plug-in publicitaire qui prend en charge AirPlay et uniquement lors de l'utilisation d'annonces pré-roll et/ou post-roll. L'utilisation d'AirPlay avec les plug-ins publicitaires Pulse, SSAI ou FreeWheel peut entraîner un comportement inattendu.</p>

<p>Si vous souhaitez également prendre en charge AirPlay 2 et permettre la sélection de plusieurs appareils pour la sortie audio, vous devrez effectuer quelques opérations supplémentaires. D'abord, vous&rsquo;Vous devrez configurer AVAudioSession afin que vous puissiez définir le <code>routePartagePolitique</code>. Par exemple:</p>

<pre><code>[AVAudioSession.sharedInstance setCategory:AVAudioSessionCategoryPlayback mode:AVAudioSessionModeMoviePlayback routeSharingPolicy:AVAudioSessionRouteSharingPolicyLongForm options:0 error:nil] ; </code></pre>

<p>Vous devrez également configurer au moins une commande de lecture via <code>MPRemoteCommandCenter</code>. Au moins vous&rsquo;Je veux configurer à la fois le <code>pauseCommande</code> et <code>playCommande</code>. Par exemple:</p>

<pre><code>MPRemoteCommandCenter *center = MPRemoteCommandCenter.sharedCommandCenter; [center.pauseCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) { [self.playbackController pause]; return MPRemoteCommandHandlerStatusSuccess; } ; [center.playCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) { [self.playbackController play]; return MPRemoteCommandHandlerStatusSuccess; } ; </code></pre>

<p>Les appareils qui exécutent iOS 11 ou une version ultérieure profiteront de <code>AVRoutePickerView</code> qui a deux méthodes déléguées. Ces méthodes déléguées sont transmises à <a href="Protocols/BCOVPUIPlayerViewDelegate.html"><code>BCOVPUIPlayerViewDelegate</code></a>. Les méthodes sont :</p>

<pre><code>- (void)routePickerViewWillBeginPresentingRoutes:(AVRoutePickerView *)routePickerView; - (void)routePickerViewDidEndPresentingRoutes :(AVRoutePickerView *)routePickerView ; </code></pre>

<p>Les <code>AVRouteDetector</code> utilisé pour découvrir les itinéraires AirPlay est disponible sur le <a href="Classes/BCOVPUIBasicControlView.html"><code>BCOVPUIBasicControlView</code></a> objet afin que vous puissiez activer ou désactiver son <code>routeDetectionEnabled</code> propriété au besoin.</p>

<p>Par pomme&rsquo;documentations : &ldquo;<em>La détection d'itinéraire augmente considérablement la consommation d'énergie et doit être désactivée lorsqu'elle&rsquo;n'est plus nécessaire.</em>&rdquo;</p>

<pre><code>// Objective-C self.playerView.controlsView.routeDetector.routeDetectionEnabled = NO; // Swift playerView?.controlsView.routeDetector.isRouteDetectionEnabled = false </code></pre>

<p>Pour plus d'informations sur l'intégration d'AirPlay 2 dans votre application, veuillez consulter le <a href="https://developer.apple.com/documentation/avfoundation/media_playback_and_selection/getting_airplay_2_into_your_app?language=objc">Installer Airplay 2 dans votre application</a> Documentation.</p>

<p><strong>Note importante: AirPlay 2 n'est pris en charge que sur les appareils exécutant iOS 11.4 ou une version ultérieure.</strong></p>

<h1>Vidéo 360 <a name="Video360"></a></h1>

<p>Le SDK Native Player inclut la prise en charge de l'affichage interactif de vidéos sphériques à 360 degrés. Les vidéos 360 doivent être taguées avec un &ldquo;projection&rdquo; propriété de champ contenant la valeur &ldquo;équirectangulaire&rdquo;. Ces vidéos seront chargées et lues de la même manière que les autres vidéos, mais elles seront affichées dans une couche OpenGL ES au lieu d'une AVPlayerLayer.</p>

<p>Noter: &ldquo;équirectangulaire&rdquo; est le seul format de projection pris en charge pour les vidéos source 360 pour le moment.</p>

<p>Le PlayerUI prend également en charge Video 360, fournissant des gestes de panoramique par défaut, une détection de mouvement gyroscopique pour la vue et un nouveau bouton Video 360 qui apparaît lorsqu'un élément Video 360 est en cours de lecture. Ce bouton n'apparaît que sur les iPhones et vous permet de basculer entre la vue normale et une &ldquo;Lunettes de réalité virtuelle&rdquo; vue, où l'écran est divisé en deux, avec la même scène rendue pour chaque œil afin que l'appareil puisse être utilisé dans une configuration montée sur la tête. Sur les iPad, aucun bouton Video 360 n'est nécessaire car il n'y a qu'un seul mode de fonctionnement : la détection de mouvement avec prise en charge des mouvements panoramiques.</p>

<p>La prise en charge de Video 360 est aussi simple que la lecture d'une vidéo. Quand le &ldquo;projection&rdquo; field est détectée, le kit de développement logiciel Native Player gère automatiquement la configuration et l'affichage de la vidéo dans OpenGL ES, et l'installation du bouton Video 360 le cas échéant.</p>

<p>Si vous lisez des vidéos 360 en dehors de Video Cloud, assurez-vous d'ajouter un &ldquo;projection&rdquo; propriété à la <a href="Classes/BCOVVideo.html"><code>BCOVVidéo</code></a> objet avec la valeur &ldquo;équirectangulaire&rdquo;.</p>

<p>Pour offrir la meilleure expérience utilisateur avec le mode VR Goggles, vous devez utiliser un <a href="Protocols/BCOVPUIPlayerViewDelegate.html"><code>BCOVPUIPlayerViewDelegate</code></a> méthode pour détecter quand ce mode est activé. Cela vous permet de forcer l'appareil en orientation paysage (car c'est la seule orientation qui a du sens pour une vue VR Goggles).</p>

<p>Le code suivant montre comment vous pouvez gérer un changement d'orientation forcé lors du basculement entre une vue 360 normale et le mode VR Goggles.</p>

<pre><code>// Définissez ce paramètre sur YES lors de l'affichage d'une vidéo avec des lunettes VR @property (nonatomic) BOOL landscapeOnly; // UIViewController override : // Nous permet de contrôler l'orientation du périphérique - (UIInterfaceOrientationMask)supportedInterfaceOrientations { if (self.landscapeOnly) { return UIInterfaceOrientationMaskLandscape; } return UIInterfaceOrientationMaskAll; } // Méthode BCOVPUIPlayerViewDelegate - (void)didSetVideo360NavigationMethod:(BCOVPUIVideo360NavigationMethod)navigationMethod projectionStyle:(BCOVVideo360ProjectionStyle)projectionStyle { switch (projectionStyle) { case BCOVVideo360ProjectionStyleNormal: NSLog(@"BCOVVideo360ProjectionStyleNormal"); self.landscapeOnly = NO; break; case BCOVVideo360ProjectionStyleVRGoggles: NSLog(@"BCOVPUIVideo360NavigationDeviceMotionTracking"); self.landscapeOnly = YES; { UIDeviceOrientation currentDeviceOrientation = [UIDevice currentDevice].orientation; switch (currentDeviceOrientation) { case UIDeviceOrientationLandscapeLeft: case UIDeviceOrientationLandscapeRight: // all good break; default: { // switch orientation NSNumber *value = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeLeft]; [[UIDevice currentDevice] setValue:value forKey:@"orientation"]; break; } } } Pause; } [UIViewController tryRotationToDeviceOrientation] ; } </code></pre>

<p>Le PlayerUI installera des gestes pour gérer la navigation dans la vidéo 360, mais si vous utilisez vos propres commandes, vous pouvez définir vous-même les paramètres d'affichage de la caméra virtuelle. Les <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> protocole&rsquo;s <code>vueProjection</code> La propriété vous permet de définir ces paramètres. La propriété est un <a href="Classes/BCOVVideo360ViewProjection.html"><code>BCOVVidéo360VoirProjection</code></a> classe avec les paramètres de base de la caméra virtuelle comme <code>la poêle</code> , <code>inclinaison</code> , et <code>Zoom</code>. Pour modifier les paramètres, faites une copie de l'instance actuelle, modifiez les paramètres de la nouvelle instance, puis attribuez-la à nouveau au <code>vueProjection</code> biens.</p>

<h2>Aperçu architectural <a name="ArchitecturalOverview"></a></h2>

<p><img src="architecture01.png" alt="Architectural Overview 1" /></p>

<p>Le point d'entrée du Brightcove Player SDK pour iOS est le <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlayerSDKManager.h">[<code>BCOVPlayerSDKManager</code>](Classes/BCOVPlayerSDKManager.html)</a> objet singleton. Ce gestionnaire gère l'enregistrement des composants du plug-in et certaines autres tâches d'entretien, mais il sert principalement de fabrique d'objets. Votre application&rsquo;Le contrôleur de vue s obtient une référence au gestionnaire et l'utilise pour créer un <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h">[<code>Contrôleur de lecture BCOV</code>](Protocoles/BCOVPlaybackController.html)</a>. Le contrôleur de lecture&rsquo;s <code>vue</code> La propriété expose une UIView contenant l'objet AVPlayerLayer qui présente finalement votre contenu vidéo à l'écran. Le contrôleur de lecture accepte également un <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L667-L793">[<code>BCOVPlaybackControllerDélégué</code>](Protocoles/BCOVPlaybackControllerDelegate.html)</a> , que vous pouvez implémenter pour répondre à divers événements de lecture vidéo.</p>

<p>Le contrôleur de lecture propose des méthodes et des propriétés pour affecter la lecture de la vidéo en cours. Cependant, en interne, le contrôleur de lecture délègue à un <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackSession.h">[<code>BCOVSession de lecture</code>](Protocoles/BCOVPlaybackSession.html)</a> objet. Les sessions de lecture effectuent le travail réel de préparation et de lecture du contenu vidéo et contiennent la vidéo&rsquo;s métadonnées et <code>AVPplayer</code>. Le contrôleur de lecture dispose de mécanismes pour passer de la session de lecture en cours à la session de lecture suivante, soit automatiquement à la fin d'une vidéo, soit manuellement avec un appel de méthode. Une fois que le contrôleur de lecture est passé à une nouvelle session, la session précédente est supprimée et ne peut plus être utilisée.</p>

<p>Il y a deux autres éléments du contrôleur de lecture : un <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackSessionProvider.h">[<code>BCOVPlaybackSessionProvider</code>](Protocoles/BCOVPlaybackSessionProvider.html)</a> , et une liste de <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L538-L655">[<code>BCOVPlaybackSessionConsommateur</code>](Protocoles/BCOVPlaybackSessionConsumer.html)</a>s. Comme son nom l'indique, le fournisseur de session de lecture est responsable de la création des sessions de lecture et de leur livraison au contrôleur de lecture. Le contrôleur de lecture délivre ensuite la session à chacun des consommateurs de session de lecture dans la liste. Les API du fournisseur de session et du consommateur de session sont conçues pour être utilisées par les développeurs de plug-ins et ne sont pas détaillées dans ce document.</p>

<p>En plus de la fonctionnalité de lecture fournie par les classes décrites ci-dessus, il existe une poignée de classes de valeur. Ceux-ci sont utilisés pour contenir des données spécifiques au Player SDK pour iOS. Chacun d'eux est décrit plus en détail dans sa propre section ci-dessous.</p>

<h2>Lecture, pause et recherche <a name="PlayPauseSeek"></a></h2>

<p>Le Brightcove Player SDK pour iOS fournit des méthodes de lecture, de pause et de recherche sur le <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a>. <strong>Il est important d'utiliser ces méthodes au lieu d'utiliser l'équivalent AVPlayer.</strong> Dans leurs implémentations par défaut, ces objets transmettent les appels directement à la méthode correspondante sur l'AVPlayer. Cependant, si vous utilisez des plugins, ils peuvent remplacer le comportement par défaut pour ajouter des fonctionnalités. Par exemple, si vous utilisez un plug-in publicitaire, appelez <a href="Protocols/BCOVPlaybackController.html#//api/name/play"><code>[Lecture BCOVPlaybackController]</code></a> la première fois peut entraîner la lecture du pré-roll avant le démarrage du contenu. Pour en savoir plus sur la façon dont un plugin peut remplacer le comportement par défaut, veuillez vous référer à chaque plugin README.md ou en recherchant une extension de catégorie sur <a href="Classes/BCOVSessionProviderExtension.html"><code>BCOVSessionProviderExtension</code></a> que le plugin peut ajouter.</p>

<p><em>L'appel direct de lecture, de pause ou de recherche sur AVPlayer peut entraîner un comportement indéfini.</em></p>

<h2>Préchargement de vidéos <a name="PreloadingVideos"></a></h2>

<p>Si vous le souhaitez, vous pouvez choisir de précharger les vidéos à venir dans une liste de lecture. Une approche possible consiste à mettre en mémoire tampon une liste de vidéos à l'aide de deux contrôleurs de lecture, par exemple :</p>

<ol>
<li>Initialiser deux contrôleurs de lecture</li>
<li>Configurez votre vue de lecteur et attribuez l'un des deux contrôleurs de lecture au playerView&rsquo;s propriété playbackController (maintenant votre contrôleur de lecture actif)</li>
<li>Une fois que votre liste de lecture est prête, attribuez la liste de lecture (ou simplement la propriété de tableau de vidéos) à une propriété au fur et à mesure que nous&rsquo;ll besoin d'accéder à chaque vidéo séparément</li>
<li>Obtenez la première vidéo du tableau videos et donnez-la au contrôleur de lecture actif (<code>[self.playbackController1 setVideos:@[self.videos.firstObject]]</code>)</li>
<li>Utilisant le <code>playController:didProgressTo:</code> méthode de délégation du contrôleur de lecture déterminer si la vidéo actuelle a suffisamment progressé jusqu'à l'endroit où vous souhaitez commencer le préchargement de la vidéo suivante</li>
<li>Une fois que vous l'avez déterminé&rsquo;Il est temps de précharger la vidéo suivante dans le tableau de vidéos et de la régler sur le contrôleur de lecture alternatif</li>
<li>Une fois la vidéo en cours terminée, réglez le contrôleur de lecture sur le playerView sur le contrôleur de lecture alternatif</li>
<li>Rincez et répétez les étapes 5 à 7</li>
</ol>


<p>Pour un exemple de travail, vous pouvez télécharger notre <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/VideoPreloading">VidéoPréchargement</a> exemple d'application de notre <a href="https://github.com/BrightcoveOS/ios-player-samples">Échantillons de joueurs</a> dépôt.</p>

<p><strong>Noter: Vous voudrez peut-être prendre en compte la quantité de mémoire disponible sur le client&rsquo;s appareil et la vitesse de leur connexion. S'ils ne sont pas sur Wifi, le préchargement d'une vidéo peut affecter la vidéo en cours&rsquo;s ressources réseau.</strong></p>

<h2>Sélection de la source (HLS, MP4, HTTP/HTTPS) <a name="SourceSelection"></a></h2>

<p>Le Brightcove Player SDK pour iOS offre aux clients la possibilité de joindre plusieurs types d'URL et de diffusion (<a href="Classes/BCOVSource.html"><code>Source BCOV</code></a> ) à une seule vidéo (<a href="Classes/BCOVVideo.html"><code>BCOVVidéo</code></a>). Par exemple, si vos vidéos sont récupérées par le service de lecture, il peut y avoir un mélange de rendus HLS ou MP4 pour une seule vidéo, ainsi que des versions HTTP et HTTPS. Laquelle de ces sources est sélectionnée est déterminée par un bloc de politique de sélection de source. La politique de sélection de source par défaut sélectionnera le premier HLS <a href="Classes/BCOVSource.html"><code>Source BCOV</code></a> sur chaque <a href="Classes/BCOVVideo.html"><code>BCOVVidéo</code></a> , avec les sources HTTPS préférées à HTTP.</p>

<p>La sélection de la source peut être remplacée en créant un <a href="Classes/BCOVBasicSessionProviderOptions.html"><code>BCOVBasicSessionProviderOptions</code></a> et l'utiliser pour créer un <a href="Classes/BCOVBasicSessionProvider.html"><code>BCOVBasicSessionProvider</code></a>. Par exemple:</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManagersharedManager] ; BCOVBasicSessionProviderOptions *options = [[BCOVBasicSessionProviderOptions alloc] init]; options.sourceSelectionPolicy = &lt;policy&gt; id&lt;BCOVPlaybackSessionProvider&gt; provider = [sdkManager createBasicSessionProviderWithOptions:options]; idBCOVPlaybackController playController = [sdkManager createPlaybackControllerWithSessionProvider:provider viewStrategy:nil]; </code></pre>

<p>Si cette politique de sélection par défaut ne fonctionne pas pour vous, il existe quelques alternatives à la sélection d'une source :</p>

<ul>
<li><p>Si vous récupérez des vidéos de Video Cloud via le service de lecture, avant d'appeler <code>[BCOVPlaybackController setVidéos :]</code> , utilisez la méthode de mise à jour sur le <code>BCOVVidéo</code> pour ne contenir que la source que vous voulez (voir le &ldquo;Valeurs&rdquo; rubrique pour plus d'informations).</p></li>
<li><p>Vous pouvez utiliser la méthode d'assistance <code>[BCOVBasicSourceSelectionPolicy sourceSelectionHLSWithScheme:scheme]</code> pour créer une politique qui préfère un schéma spécifique. Il s'agit de la méthode utilisée pour créer la politique de sélection de source par défaut qui préfère HTTPS.</p></li>
<li><p>Semblable à la mise à jour de l'objet vidéo, vous pouvez également implémenter votre propre bloc de sélection de source.</p>

<pre><code> options.sourceSelectionPolicy = ^ BCOVSource *(BCOVVideo *vidéo) { &lt;Check video.sources for source&gt; &lt;Return source&gt; } ; </code></pre></li>
</ul>


<p>Veuillez noter qu'il existe des limitations de l'App Store concernant l'utilisation de vidéos MP4. Consultez les dernières informations Apple Developer pour plus de détails.</p>

<h2>Définition d'un débit binaire préféré <a name="PreferredBitrate"></a></h2>

<p>Le Brightcove Player SDK pour iOS permet de définir le débit binaire préféré pour une vidéo. Vous pouvez créer un <a href="Classes/BCOVPreferredBitrateConfig.html">BCOVPreferredBitrateConfig</a> objet qui contient les options de débit binaire souhaitées, ainsi qu'une configuration pour le contrôleur de vue qui est créé pour afficher les options.</p>

<p>Le titre du menu est facultatif. Les options de débit binaire sont un tableau de NSDictionary&rsquo;s avec chaque dictionnaire ayant une paire clé:valeur. La clé sera utilisée comme nom d'option et la valeur est un NSNumber avec le débit pour cette option en bps (bits par seconde). Les débits que vous saisissez sont des valeurs qui peuvent être mappées aux débits des rendus de vos ressources vidéo. Vous pouvez en savoir plus sur les rendus dans <a href="https://studio.support.brightcove.com/admin/ingest-profiles-best-practices.html">Meilleures pratiques pour les profils d'ingestion</a>.</p>

<p>Voici un exemple:</p>

<pre><code>BCOVPUIPlayerViewOptions *options = [[BCOVPUIPlayerViewOptions alloc] init]; options.preferredBitrateConfig = [BCOVPreferredBitrateConfig configWithMenuTitle:@"Sélectionnez une option" andBitrateOptions:@[@{@"Auto":@(0)} , @{@"Setting 1":@(aBitrateValue)} , @{@"Setting 2":@(aBitrateValue)}]] ; </code></pre>

<p>Lorsque l'utilisateur final sélectionne l'une des options, le <a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">préféréPeakBitRate</a> La propriété de l'AVPlayerItem actuel sera définie sur l'option&rsquo;valeur de s. Si la vidéo est dans une liste de lecture, la prochaine vidéo lue aura également la valeur favoritePeakBitRate définie.</p>

<p>Après avoir défini une valeur non nulle pour <a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">préféréPeakBitRate</a> vous ne remarquerez peut-être pas de différence de qualité tant qu'AVPlayer n'a pas atteint la fin de son cache tampon actuel.</p>

<p>Vous pouvez également utiliser le <code>configWithMenuTitle:bitrateOptions:andIndexofInitialSelection :</code> initialiseur qui offre la possibilité de définir l'index de votre valeur initiale préférée. L'index doit correspondre à l'index de l'option souhaitée dans le <code>BitrateOptions</code> déployer.</p>

<p>Vous pouvez également utiliser le <code>setPreferredPeakBitRate :</code> méthode sur votre <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> objet pour définir par programmation le débit binaire préféré pour les sessions en cours et futures.</p>

<p>REMARQUE: Les utilisateurs finaux doivent avoir un moyen de revenir à la valeur par défaut (0) de <a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">préféréPeakBitRate</a>. Vous pouvez le faire en fournissant une option avec une valeur de débit binaire de 0. Si vous ne fournissez pas d'option de débit binaire de 0 un &ldquo;Automatique&rdquo; sera ajoutée à votre liste d'options pour l'utilisateur final.</p>

<p>S'il vous plaît voir Apple&rsquo;documentation sur <a href="https://developer.apple.com/documentation/avfoundation/avplayeritem/1388541-preferredpeakbitrate">préféréPeakBitRate</a> pour plus d'informations.</p>

<h2>Obtention d'informations sur le contenu et la lecture des annonces <a name="PlaybackInformation"></a></h2>

<p>Le Brightcove Player SDK pour iOS fournit deux mécanismes pour obtenir des informations de lecture. Le contrôleur de lecture fournit une propriété de délégué qui implémente <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L667-L793">[<code>BCOVPlaybackControllerDélégué</code>](Protocoles/BCOVPlaybackControllerDelegate.html)</a>. Un délégué peut implémenter ces méthodes facultatives pour être informé des métadonnées de lecture telles que la progression, les changements de durée et d'autres événements. Si un plug-in publicitaire est installé, il peut également utiliser ce délégué pour fournir des informations sur <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVAdvertising.h#L120-L192">lecture d'annonces</a>. Les <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L630-L641">événement du cycle de vie</a> La méthode délégué fournit des événements pour signaler les changements d'état de lecture. Par exemple, lorsqu'un joueur passe de l'état de pause à l'état de lecture, la méthode de délégué d'événement de cycle de vie sera appelée avec le <code>kBCOVPlaybackSessionLifecycleEventPlay</code> un événement. Les événements du cycle de vie par défaut sont déclarés dans <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/master/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackSession.h">[<code>BCOVSession de lecture</code>](Protocoles/BCOVPlaybackSession.html)</a>. Les plugins fournis par Brightcove ajoutent des événements de cycle de vie supplémentaires qui sont définis dans chaque plugin.</p>

<p>Le contrôleur de lecture permet un seul délégué. Dans de nombreux cas, cela suffira pour récupérer des informations ; les implémentations déléguées peuvent diffuser des valeurs et des événements dans différentes parties de l'application si nécessaire. Dans les cas où plusieurs délégués seraient nécessaires, comme c'est le cas lors du développement d'un plugin, le <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L538-L655">[<code>BCOVPlaybackSessionConsommateur</code>](Protocoles/BCOVPlaybackSessionConsumer.html)</a> les délégués fournissent des fonctionnalités équivalentes au <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVPlaybackController.h#L667-L793">[<code>BCOVPlaybackControllerDélégué</code>](Protocoles/BCOVPlaybackControllerDelegate.html)</a> méthodes, y compris <a href="https://github.com/brightcove/brightcove-player-sdk-ios/blob/fd5e766693e533854f202f270d3d62e32ceaae04/ios/dynamic/BrightcovePlayerSDK.framework/Headers/BCOVAdvertising.h#L195-L259">données publicitaires</a>.</p>

<p>Voici un exemple d'utilisation <a href="Protocols/BCOVPlaybackSessionConsumer.html"><code>BCOVPlaybackSessionConsommateur</code></a> pour créer un plugin d'analyse :</p>

<pre>@interface XYZAnalytics :<code> NSObject BCOVPlaybackSessionConsumer @end @implementation XYZAnalytics - (void)playbackSession:(idBCOVPlaybackSession)session didProgressTo:(NSTimeInterval)progress { //react to progress event } @finir </code></pre>

<p>Pour utiliser le plugin :</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManagersharedManager] ; id&lt;BCOVPlaybackController&gt; contrôleur = [sdkManager createPlaybackController]; XYZAnalytics *analytics = [[XYZAnalytics alloc] init] ; [contrôleur addSessionConsumer:analytics] ; </code></pre>

<h2>Gestion des interruptions et des ralentissements du réseau <a name="HandlingNetworkInterruptionsAndSlowdowns"></a></h2>

<p>Lorsque l'application subit des interruptions de réseau, le <code>AVPplayer</code> utilisé par le <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> peut arrêter de tenter de récupérer si l'interruption dure trop longtemps. Si cela se produit, la méthode déléguée du cycle de vie sera appelée avec un <code>kBCOVPlaybackSessionLifecycleEventFailedToPlayToEndTime</code> un événement. Lorsque cet événement se produit, la lecture <strong>Ne fera pas</strong> récupérer automatiquement. Afin de récupérer de cet événement, vous devrez détecter quand le réseau récupère dans votre code client.</p>

<p>Une fois que vous avez déterminé que le réseau a récupéré, vous pouvez utiliser <code> - [</code>[BCOVPlaybackController resumeVideoAtTime:withAutoPlay:]<code>](Protocols/BCOVPlaybackController.html#//api/name/resumeVideoAtTime:withAutoPlay:)</code> pour réinitialiser le lecteur. Vous devrez garder une trace de l'endroit où vous souhaitez reprendre. Le lecteur fera de son mieux pour supprimer les événements du cycle de vie et les événements de progression, afin d'empêcher la relecture des publicités ou l'interférence des analyses.</p>

<p>En appelant <code> - [</code>[BCOVPlaybackController resumeVideoAtTime:withAutoPlay:]<code>](Protocols/BCOVPlaybackController.html#//api/name/resumeVideoAtTime:withAutoPlay:)</code> , le joueur enverra un événement de cycle de vie de type <code>kBCOVLectureSessionLifecycleEventResumeBegin</code> . <code>kBCOVPlaybackSessionLifecycleEventResumeComplete</code> sera envoyé si cette action réussit, sinon <code>kBCOVPlaybackSessionLifecycleEventResumeFail</code> sera envoyé.</p>

<p>Vous devez attendre avant d'appeler <code> - [</code>[BCOVPlaybackController resumeVideoAtTime:withAutoPlay:]<code>](Protocols/BCOVPlaybackController.html#//api/name/resumeVideoAtTime:withAutoPlay:)</code> une deuxième fois jusqu'à ce que vous ayez reçu soit <code>kBCOVPlaybackSessionLifecycleEventResumeComplete</code> ou <code>kBCOVPlaybackSessionLifecycleEventResumeFail</code> de l'appel précédent. Vous pouvez souhaiter imposer une limite de nouvelle tentative avant de donner à l'utilisateur un message indiquant que son réseau est trop instable.</p>

<p>Quand le <code>AVPplayer</code> est toujours en mesure d'accéder au réseau, mais la vidéo se bloque car le réseau est trop lent, la méthode de délégué du cycle de vie sera appelée avec un <code>kBCOVPlaybackSessionLifecycleEventPlaybackStaled</code> un événement. Lorsque la lecture pourra reprendre, la méthode déléguée du cycle de vie sera appelée avec un <code>kBCOVLectureSessionLifecycleEventLectureRécupéré</code> un événement. Ces événements ne couvrent que le cas où la lecture normale s'est arrêtée et ne couvrent pas la mise en mémoire tampon qui se produit pendant une recherche ou un chargement initial de la vidéo.</p>

<p>Lorsque la vidéo se charge initialement, lorsqu'une recherche se produit ou lorsque la lecture s'arrête en raison d'un réseau lent, la méthode de délégué du cycle de vie sera appelée avec un <code>kBCOVPlaybackSessionLifecycleEventPlaybackBufferVide</code> un événement. Lorsque la lecture pourra reprendre, la méthode déléguée du cycle de vie sera appelée avec un <code>kBCOVLectureSessionLifecycleEventLectureProbableÀContinuer</code> un événement.</p>

<h2>Sous-classement <a name="Subclassing"></a></h2>

<p>Sauf indication contraire explicite, aucune des classes du SDK Player pour iOS n'est conçue pour être sous-classée. La création d'une sous-classe d'une classe SDK qui n'est pas explicitement conçue pour être sous-classée, en particulier l'une des classes de valeur, peut entraîner un comportement imprévisible.</p>

<h2>Valeurs <a name="Values"></a></h2>

<p>Aussi connu sous le nom &ldquo;objets de modèle&rdquo; , ces classes (<a href="Classes/BCOVPlaylist.html"><code>BCOVPlaylist</code></a> , <a href="Classes/BCOVVideo.html"><code>BCOVVidéo</code></a> , <a href="Classes/BCOVSource.html"><code>Source BCOV</code></a> , <a href="Classes/BCOVCuePoint.html"><code>BCOVCuePoint</code></a> , <a href="Classes/BCOVCuePointCollection.html"><code>BCOVCuePointCollection</code></a> ) sont utilisés pour représenter les données dans le SDK du lecteur pour iOS. Il est crucial de comprendre que ces types de données sont traités comme <em>valeurs</em>, plutôt que <em>identités</em>. Par cela, nous entendons que si vous avez deux instances d'une classe de valeur qui ont exactement les mêmes données, elles représentent la même idée ou valeur, même s'il s'agit techniquement de deux objets différents à des adresses mémoire distinctes. En d'autres termes, ni le code SDK ni votre code client ne doivent jamais utiliser de comparaisons d'identité (&ldquo;égalité de pointeur&rdquo; ) avec des objets de valeur. Au lieu de cela, chaque classe de valeur implémente <code>-est égal:</code> et fournit une surcharge de méthode d'égalité spécifique à la classe, qui doit être utilisée à la place.</p>

<p>C'est mauvais:</p>

<pre><code>if (myVideo == session.video) // Pourrait conduire à des bugs ! </code></pre>

<p>Ceux-ci sont bons (et fonctionnellement équivalents) :</p>

<pre><code>if ([myVideo isEqualToVideo:session.video]) if ([myVideo isEqual:session.video]) </code></pre>

<p>Les composants internes du Player SDK pour iOS peuvent faire des choses telles que mémoriser des valeurs ou faire des copies défensives, donc compter sur l'adresse du pointeur pour vérifier l'égalité finira par vous causer de la douleur.</p>

<p>Une autre qualité des classes de valeur dans le SDK Player pour iOS est qu'elles sont <em>immuable</em>. Une fois que vous avez une instance d'une valeur, vous ne devez en aucun cas essayer de subvertir cette immutabilité, car cela peut conduire à un comportement imprévisible. Si dans votre code vous souhaitez &ldquo;modifier&rdquo; une valeur en quelque sorte, votre seul recours est de créer une nouvelle valeur. Comme commodité pour aider les clients à obtenir &ldquo;modifié&rdquo; valeurs, chacune des classes de valeur offre une <code>-mettre à jour:</code> méthode qui prend un bloc qui vous permet d'opérer sur une copie mutable de la valeur d'origine.</p>

<p>Voici un exemple d'utilisation de cette méthode pour créer un &ldquo;modifié&rdquo; version d'un objet vidéo existant, mais avec des propriétés différentes :</p>

<pre><code>BCOVVidéo *vidéo1; // (les propriétés incluent une clé "foo" dont la valeur est "bar") BCOVVideo *video2 = [video1 update:^(idBCOVMutableVideo mutable) { mutable.properties = @{ @"foo": @"bar" } ; }] ; NSLog(@"foo est %@", video1.properties[@"foo"]); // affiche "foo is bar" NSLog(@"foo is %@", video2.properties[@"foo"]); // affiche "foo is quux" // video1 et video2 sont toujours des objets immuables : video1.properties = otherDictionary; // provoque une erreur de compilation video2.properties = otherDictionary; // provoque une erreur du compilateur </code></pre>

<p>Comme vous pouvez le voir dans l'exemple, <code>vidéo1</code> n'a pas été modifié par le <code>-mettre à jour</code> appel de méthode. Au lieu de cela, cette méthode renvoie une copie de <code>vidéo1</code> , sauf avec les modifications apportées dans le corps du bloc. Vous ne devez jamais permettre à la copie modifiable d'échapper au bloc (par exemple en l'affectant à un <code>__bloquer</code> variable), utilisez à la place l'objet immuable renvoyé par le <code>-mettre à jour</code> méthode après avoir effectué vos modifications.</p>

<h2>Récupération des actifs Brightcove à l'aide du service de lecture <a name="PlaybackService"></a></h2>

<p>La classe de service de lecture, <a href="Classes/BCOVPlaybackService.html"><code>BCOVPlaybackService</code></a> , fournit des fonctionnalités pour récupérer vos ressources vidéo et listes de lecture Brightcove via le <a href="https://apis.support.brightcove.com/playback/getting-started/overview-playback-api.html">API de lecture Brightcove</a> , y compris des métadonnées riches telles que des pistes de texte, des aperçus et des vignettes. L'exemple suivant montre comment récupérer une vidéo avec un ID vidéo. Méthodes pour récupérer une vidéo ou une liste de lecture avec cette vidéo&rsquo;Les identifiants de référence sont également disponibles.</p>

<pre><code>[1] NSString *policyKey = &lt;votre-clé-politique&gt; ; NSString *accountId = &lt;your-account-id&gt;; NSString *videoID = &lt;votre-vidéo-id&gt; ; BCOVPlayerSDKManager *manager = [BCOVPlayerSDKManagersharedManager] ; id&lt;BCOVPlaybackController&gt; controller = [manager createPlaybackControllerWithViewStrategy:nil]; [self.view addSubview:controller.view] ; BCOVPlaybackService *playbackService = [[BCOVPlaybackService alloc] initWithAccountId:accountId policyKey:policyKey]; [playbackService findVideoWithVideoID:videoID parameters:nil achèvement:^(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error) { [controller setVideos:@[ video ]]; [controller play]; } ; </code></pre>

<ol>
<li>Le service de lecture demande <strong>clé de stratégie</strong> pour l'authentification. Pour en savoir plus sur la clé de politique et comment en obtenir une, veuillez vous référer à la <a href="https://apis.support.brightcove.com/policy/getting-started/policy-keys.html">documentation clé de la politique</a>.</li>
</ol>


<p>**REMARQUE: Si vous utilisez le service d'autorisation de lecture, veuillez consulter le <a href="#PlaybackAuthorizationService">section</a> de ce fichier README lié à cette fonctionnalité.</p>

<p><strong>Pagination de la liste de lecture</strong></p>

<p>Pour <code></code>BCOVPlaybackService` méthodes qui renvoient une liste de lecture, vous pouvez demander une liste de lecture partielle, ou &ldquo;pages&rdquo; de la liste de lecture en spécifiant un paramètre de limite et de décalage dans le dictionnaire des paramètres. La limite spécifie le nombre maximum de vidéos qui seront renvoyées, et le décalage spécifie l'index dans la liste de lecture auquel les vidéos seront renvoyées.</p>

<p>Par exemple, si vous avez une liste de lecture avec 100 vidéos, vous ne pouvez demander que 6 vidéos à partir de la vidéo numéro 10 comme suit :</p>

<pre><code> NSDictionary *paramètres = @{ @"limit": @6, @"offset": @10 } ; [playbackService findPlaylistWithPlaylistID:playlistID parameters : achèvement des paramètres :^(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error) { [controller setVideos: playlist]; [controller play]; } ; </code></pre>

<h2>Voir la stratégie <a name="ViewStrategy"></a></h2>

<p>Les <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> l'objet est construit avec une stratégie de vue, ce qui vous permet, en tant que client du SDK, de définir l'objet UIView exact qui est renvoyé par le contrôleur de lecture&rsquo;s vue propriété. Ceci est important lors de l'utilisation de plugins qui affectent le contrôleur de lecture&rsquo;s vue, comme un plug-in publicitaire qui superpose la vue vidéo avec une vue publicitaire. De nombreuses applications n'auront pas besoin de créer une stratégie de vue et peuvent simplement passer <code>néant</code> lors de la création d'un nouveau contrôleur de lecture. Cela créera une vue vidéo standard dans le contrôleur de lecture.</p>

<p>Les <a href="Blocks/BCOVPlaybackControllerViewStrategy.html"><code>BCOVPlaybackControllerViewStrategy</code></a> typedef aliase (et documente) cette signature de bloc plus complexe :</p>

<p><code>objc UIView *(^)(UIView *videoView, idBCOVPlaybackController playController); </code></p>

<p>Cette signature décrit un bloc Objective-C qui renvoie une UIView et prend deux paramètres : une UIView et un contrôleur de lecture. La valeur de retour est l'objet UIView que le contrôleur de lecture&rsquo;La propriété de vue s pointera vers. Le premier paramètre est une UIView qui contient la couche vidéo, la UIView affichera la vidéo. Le deuxième paramètre est l'objet contrôleur de lecture auquel la stratégie de vue a été donnée, le contrôleur de lecture peut être utilisé pour ajouter des consommateurs de session nécessaires tels que des commandes vidéo ou des commandes publicitaires.</p>

<p>Exemple de mise en œuvre de la stratégie de vue :</p>

<p>```objc BCOVPlaybackControllerViewStrategy viewStrategy = ^(UIView *videoView, id<BCOVPlaybackController> playController) {</p>

<pre><code>// Créez des contrôles personnalisés pour la vue vidéo, // et composez les deux dans une vue conteneur. [1] UIView&lt;BCOVPlaybackSessionConsumer&gt; *myControlsView = [[MyControlsView alloc] init]; [2] UIView *controlsAndVideoView = [[UIView alloc] init]; [3] [controlsAndVideoView addSubview:videoView] ; [controlsAndVideoView addSubview:myControlsView] ; // Composez le conteneur avec une vue publicitaire // dans une autre vue conteneur. [4] UIView&lt;BCOVPlaybackSessionConsumer&gt; *adView = [[SomeAdPluginView alloc] init]; [5] UIView *adAndVideoView = [[UIView alloc] init]; [6] [adAndVideoView addSubview:controlsAndVideoView] ; [adAndVideoView addSubview:adView] ; [7] [playbackController addSessionConsumer:myControlsView] ; [playbackController addSessionConsumer:adView] ; // Cette vue conteneur deviendra `playbackController.view`. retourner adAndVideoView ; </code></pre>

<p>} ; <code>`` Décomposer le code en étapes : [1] Créez une vue de contrôles personnalisés conforme à la </code>BCOVPlaybackSessionConsommateur<code> protocole. </code>BCOVPlaybackSessionConsommateur<code>Le protocole permet de recevoir des informations de lecture de base pour chaque vidéo en plus de la publicité. [2] Créez une vue de conteneur pour la vue vidéo et les commandes personnalisées. [3] Ajoutez comme sous-vue le conteneur vidéo et les contrôles personnalisés. La hiérarchie est composée dans le même ordre que les vues sont ajoutées. [4] Créez une vue de contrôle des annonces conforme aux </code>Protocole BCOVPlaybackSessionConsumer`. [5] Créez une vue conteneur pour la vue vidéo et les commandes, et la vue publicitaire. [6] Ajoutez comme sous-vue le conteneur vidéo et la vue des commandes publicitaires. [7] Enregistrez la vue des contrôles personnalisés et la vue des contrôles publicitaires en tant que consommateurs de session à l'aide de l'objet contrôleur de lecture renvoyé par le bloc.</p>

<p>Il y a une mise en garde à l'utilisation d'une stratégie d'affichage : vous ne devez pas accéder au contrôleur de lecture&rsquo;s <code>vue</code> propriété à partir du bloc de stratégie de vue. Puisque le bloc est appelé <em>car</em> le contrôleur de lecture&rsquo;s <code>vue</code> propriété a été accédée pour la première fois, en accédant au <code>vue</code> propriété à nouveau <em>dans</em> le bloc de stratégie de vue fera planter votre programme.</p>

<h2>Lecture de vidéo en arrière-plan <a name="BackgroundVideo"></a></h2>

<p>Par défaut, lorsqu'une application iOS est envoyée en arrière-plan ou que l'appareil est verrouillé, iOS met en pause toute vidéo en cours de lecture. Pour modifier ce comportement, définissez le <code>allowBackgroundAudioPlayback</code> propriété de la <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> s'opposer à <code>OUI</code>. (La valeur par défaut est <code>NON</code> , indiquant que la lecture s'arrêtera en arrière-plan.)</p>

<p>Vous devez également suivre les directives définies par Apple dans <a href="https://developer.apple.com/library/ios/qa/qa1668">Questions et réponses techniques QA1668</a> pour définir les modes d'arrière-plan et la catégorie de session audio appropriés pour votre application.</p>

<p>Ce&rsquo;est important que le <code>AVPlayerLayer</code> être détaché de la <code>AVPplayer</code> avant que l'application ne soit passée à l'arrière-plan (et rattachée lorsque l'application revient au premier plan). Le Brightcove Player SDK s'en chargera pour vous lorsque <code>allowBackgroundAudioPlayback</code> est réglé sur <code>OUI</code>.</p>

<p>Enfin, lors de la lecture de vidéos d'arrière-plan (et en particulier lors de l'utilisation de listes de lecture), vous devez utiliser l'iOS <code>MPRemoteCommandCenter</code> API pour donner à l'utilisateur le contrôle de la lecture sur l'écran de verrouillage et dans le centre de contrôle.</p>

<h2>Image dans l'image <a name="PIP"></a></h2>

<p>Pour activer Picture-in-Picture dans votre application, définissez le <code>showPictureInPictureButton</code> propriété de la <a href="Classes/BCOVPUIPlayerViewOptions.html"><code>BCOVPUIPlayerViewOptions</code></a> s'opposer à <code>OUI</code> lors de l'instanciation de votre <a href="Classes/BCOVPUIPlayerView.html"><code>BCOVPUIPlayerView</code></a> objet. Le bouton Picture-in-Picture s'affichera alors dans la barre de commandes de tout appareil qui le prend en charge.</p>

<p>Pour que Picture-in-Picture fonctionne correctement, vous devez vous assurer que le <code>Audio, AirPlay et Image dans l'image</code> le mode est activé dans le <code>Modes d'arrière-plan</code> section de l'onglet Capacités cibles de votre projet. Vous devez également suivre les directives définies par Apple dans <a href="https://developer.apple.com/library/ios/qa/qa1668">Questions et réponses techniques QA1668</a> pour définir les modes d'arrière-plan et la catégorie de session audio appropriés pour votre application.</p>

<p>Les <code>AVPictureInPictureControllerDélégué</code> les méthodes sont transmises via <a href="Protocols/BCOVPUIPlayerViewDelegate.html"><code>BCOVPUIPlayerViewDelegate</code></a>. Ces méthodes sont :</p>

<pre><code>- (void)pictureInPictureControllerDidStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureControllerDidStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureControllerWillStartPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureControllerWillStopPictureInPicture:(AVPictureInPictureController *)pictureInPictureController; - (void)pictureInPictureController:(AVPictureInPictureController *)pictureInPictureController failedToStartPictureInPictureWithError:(NSError *)error </code></pre>

<p>Voir Apple&rsquo;s <a href="https://developer.apple.com/documentation/avkit/avpictureinpicturecontrollerdelegate">AVPictureInPictureControllerDélégué</a> documentation pour plus d'informations.</p>

<p>Pour implémenter votre propre comportement Picture-in-Picture, gardez le <code>pictureInPictureActive</code> propriété de <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> mis à jour avec le statut Picture-in-Picture. Si vous utilisez le <code>AVPictureInPictureController</code> , vous pouvez utiliser le <code>pictureInPictureControllerDidStartPictureInPicture :</code> et <code>pictureInPictureControllerDidStopPictureInPicture :</code> déléguer des méthodes pour mettre à jour cette propriété.</p>

<p>Vous pouvez en savoir plus sur l'implémentation de Picture-in-Picture dans Apple&rsquo;s <a href="https://developer.apple.com/documentation/avkit/adopting_picture_in_picture_in_a_custom_player">Adopter l'image dans l'image dans un lecteur personnalisé</a> Documentation.</p>

<p>L'utilisation d'une liste de lecture de vidéos avec des formats mixtes avec image dans l'image entraînera la fermeture de la fenêtre image dans l'image entre chaque vidéo.</p>

<p>iOS et iPadOS 14 ont introduit un comportement d'image dans l'image automatique qui peut être activé/désactivé dans <code>Paramètres &gt; Général &gt; Image dans l'image</code>. Pour que cette fonctionnalité fonctionne comme prévu, la vue du lecteur doit être égale à la largeur de l'écran et la hauteur doit avoir un rapport d'au moins 0,57 à la largeur (16:9 ou plus). Si la largeur ou la hauteur de la vue de votre lecteur est inférieure à ces valeurs, Picture-in-Picture peut ne pas être déclenché automatiquement lorsque l'application entre en arrière-plan.</p>

<p>Important:<strong> Le SDK Brightcove Native Player&rsquo;s La fonctionnalité Picture-in-Picture ne prend pas en charge les vidéos avec lecture publicitaire. Essayer d'utiliser une vidéo avec des publicités avec la fonctionnalité Picture-in-Picture active entraînera un comportement inattendu.</strong></p>

<h2>Recherche de vignettes <a name="ThumbnailSeeking"></a></h2>

<p>La recherche de vignettes permet aux utilisateurs de faire glisser la tête de lecture le long de la chronologie et d'afficher les vignettes comme un aperçu du contenu associé. Cela donne aux utilisateurs la possibilité de parcourir rapidement un fichier vidéo et de trouver le contenu qui les intéresse.</p>

<p>Cette fonctionnalité est également appelée Trick Play par Apple et est référencée dans leur <a href="https://developer.apple.com/documentation/http_live_streaming/hls_authoring_specification_for_apple_devices?language=objc">Spécification de création HLS</a>.</p>

<p>Cette fonction est activée par défaut. Si vous souhaitez désactiver la recherche de vignettes, vous pouvez le faire en définissant le <code>miniatureRechercheActivé</code> propriété sur votre <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> à <code>NON</code>.</p>

<pre><code>self.playbackController.thumbnailSeekingEnabled = NON; </code></pre>

<p>Vous pouvez personnaliser la disposition de l'aperçu miniature en utilisant une méthode déléguée avec votre <a href="Classes/BCOVPUIPlayerView.html"><code>BCOVPUIPlayerView</code></a> ou <a href="Classes/BCOVTVPlayerView.html"><code>BCOVTVPlayerView</code></a>.</p>

<p>Sur iOS, vous pouvez régler la hauteur, la largeur et le décalage vertical :</p>

<pre><code>- (void) setupPlayerView { BCOVPUIPlayerView *playerView = [[BCOVPUIPlayerView alloc] initWithPlaybackController:nil]; playerView.delegate = self; ... } #pragma mark - BCOVPUIPlayerViewDelegate - (CGRect)playerViewShouldDisplayThumbnailPreviewWithRect:(BCOVPUIPlayerView *)playerView { CGFloat width = 100; CGFloat height = 56; CGFloat verticalOffset = -60; CGFloat modifier = 1; if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) { modifier = 2; } return CGRectMake(0, verticalOffset * modificateur, largeur * modificateur, hauteur * modificateur); } </code></pre>

<p>Sur tvOS, vous pouvez régler la hauteur et la largeur :</p>

<pre><code>- (void) setupPlayerView { self.playerView = [[BCOVTVPlayerView alloc] initWithOptions:nil]; self.playerView.delegate = self; ... } #pragma mark - BCOVTVPlayerViewDelegate - (CGSize)playerViewShouldDisplayThumbnailPreviewWithSize:(BCOVTVPlayerView *)playerView { CGSize size = self.view.frame.size; size.width = size.width / 6; size.height = size.height / 6; return size; } </code></pre>

<p>Si vous construisez manuellement un <a href="Classes/BCOVVideo.html"><code>BCOVVidéo</code></a> objet, vous pouvez définir l'URL à utiliser pour la source I-FRAME :</p>

<pre><code>BCOVVideo *video = [BCOVVideo videoWithURL:[NSURL URLWithString:@"https://mydomain.com/master.m3u8"]] ; video = [mise à jour vidéo :^(id&lt;BCOVMutableVideo&gt; mutableVideo) { mutableVideo.iFramePlaylistURL = [NSURL URLWithString:@"https://mydomain.com/iframe.m3u8"]; } ; </code></pre>

<p>Le nettoyage des vignettes n'est disponible que pour les vidéos en ligne ; les vidéos téléchargées/hors ligne ne prennent pas en charge cette fonctionnalité.</p>

<h2>Erreurs de suivi <a name="TrackingErrors"></a></h2>

<p>Les erreurs de lecture sont généralement gérées et signalées via les événements de lecture vidéo du contrôleur de lecture. Si vous avez besoin d'approfondir et de suivre les problèmes avec des vidéos ou des sessions d'applications particulières, vous pouvez profiter du Brightcove Player SDK&rsquo;s <em>ID de session</em>. L'ID de session est une propriété du <a href="Classes/BCOVPlayerSDKManager.html"><code>BCOVPlayerSDKManager</code></a> que vous pouvez récupérer comme ceci :</p>

<pre><code>NSString *sdkSessionID = BCOVPlayerSDKManager.sharedManager.sessionID; </code></pre>

<p>L'ID de session est une chaîne unique qui ne change pas pendant le cycle de vie de l'application. Cette chaîne est signalée avec diverses autres données d'analyse aux serveurs de métriques Brightcove. Si vous rencontrez des problèmes avec une instance d'application ou une vidéo particulière, vous pouvez enregistrer l'ID de session et le renvoyer aux serveurs de votre entreprise. Vous pouvez ensuite envoyer l'ID de session, l'ID vidéo et toute autre donnée pertinente aux ingénieurs de service Brightcove pour aider à diagnostiquer tout problème.</p>

<h2>Combiner des plugins <a name="CombiningPlugins"></a></h2>

<p>Si vous devez combiner des plugins Player SDK, par exemple pour ajouter des sous-titres à une vidéo protégée par DRM qui diffuse des publicités gérées par Google IMA, <code>Fournisseurs de session BCOV</code> de chaque plugin sont créés et enchaînés et la chaîne est utilisée pour construire le <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a>.</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManagersharedManager] ; IMASettings *imaSettings = [[IMASettings alloc] init]; imaSettings.ppid = kViewControllerIMAPublisherID; imaSettings.language = kViewControllerIMALanguage; imaSettings.enableBackgroundPlayback = self.allowBackgroundAudioPlayback; IMAAdsRenderingSettings *renderSettings = [[IMAAdsRenderingSettings alloc] init]; renderSettings.webOpenerPresentingController = self; BCOVIMAAdsRequestPolicy *adsRequestPolicy = [BCOVIMAAdsRequestPolicy videoPropertiesVMAPAdTagUrlAdsRequestPolicy]; // crée le fournisseur de session de sous-titres side-car. il n'a pas de fournisseur de session en amont. id&lt;BCOVPlaybackSessionProvider&gt; *sidecarSessionProvider = [sdkManager createSidecarSubtitlesSessionProviderWithUpstreamSessionProvider:nil]; // crée le fournisseur de session IMA avec un fournisseur de session de sous-titres side-car en amont. id&lt;BCOVPlaybackSessionProvider&gt; *imaSessionProvider = [sdkManager createIMASessionProviderWithSettings:imaSettings adsRenderingSettings:renderSettings adsRequestPolicy:adsRequestPolicy adContainer:self.playersionView.contentOverlayView compagnonSlots:nil amontSvidesside] // crée le contrôleur de lecture à l'aide de la chaîne de fournisseur de session. id&lt;BCOVPlaybackController&gt; *playbackController = [sdkManager createPlaybackControllerWithSessionProvider:imaSessionProvider viewStrategy:nil]; </code></pre>

<h1>Optimisation de la mémoire tampon <a name="BufferOptimization"></a></h1>

<h2>Aperçu</h2>

<p>Les développeurs contrôlent la taille de la mémoire tampon de lecture avant utilisée par le <code>AVPplayer</code>. Cela se fait en réglant le <code>préféréForwardBufferDuration</code> propriété dans le <code>AVPlayerItem</code> classer.</p>

<p>Par défaut, le Brightcove Native Player SDK définit le <code>préféréForwardBufferDuration</code> propriété d'une manière qui optimise la bande passante globale sans sacrifier la qualité de lecture. Ce comportement peut être remplacé par vos propres valeurs.</p>

<h2>Comportement par défaut</h2>

<p>Tout le monde paie pour la bande passante, donc&rsquo;Il est important de réduire la consommation de bande passante sans affecter la qualité de lecture. Nouveau avec la version 5.2.0, le Brightcove Native Player SDK gère la taille de la mémoire tampon pour vous de manière dynamique pendant la lecture de la vidéo.</p>

<p>Avant iOS 10, le <code>AVPplayer</code> mis en mémoire tampon autant de données vidéo que possible, jusqu'à environ 50 mégaoctets. C'est bien pour le modèle de visualisation vidéo où un utilisateur sélectionne une vidéo puis la regarde jusqu'à la fin, mais de nombreuses applications modernes maintenant &ldquo;taquiner&rdquo; vidéos avec lecture automatique, en espérant obtenir un engagement après quelques secondes. De nombreux utilisateurs passent simplement à différentes vidéos. Avec une mise en mémoire tampon agressive, vous pouvez vous retrouver avec plusieurs minutes de vidéo mise en mémoire tampon qui sont perdues à chaque impression vidéo.</p>

<p>Le Brightcove Native Player SDK résout ce problème en démarrant la vidéo avec une petite mémoire tampon de base, puis en l'augmentant à mesure que l'utilisateur regarde davantage la vidéo. Après un certain point, la taille de la mémoire tampon est plafonnée car il n'est ni pratique ni utile de la rendre trop grande.</p>

<h2>Modification du comportement par défaut</h2>

<p>Si vous souhaitez conserver le comportement par défaut du Brightcove Native Player SDK, mais modifier les valeurs minimale et maximale utilisées pour les tailles de tampon, vous pouvez procéder comme suit lors de la configuration du <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a>:</p>

<pre><code>// Créer un dictionnaire mutable pour contenir de nouvelles valeurs NSMutableDictionary *options = self.playbackController.options.mutableCopy; // Définir de nouvelles valeurs dans les options du dictionnaire[kBCOVBufferOptimizerMethodKey] = @(BCOVBufferOptimizerMethodDefault); options[kBCOVBufferOptimizerMinimumDurationKey] = @(min); options[kBCOVBufferOptimizerMaximumDurationKey] = @(max); // Définir un nouveau dictionnaire dans votre contrôleur de lecture self.playbackController.options = options; </code></pre>

<p>Ces options doivent être définies avant d'appeler <code>-BCOVPlaybackController setVidéos :</code>.</p>

<p><code>min</code> et <code>max</code> valeurs:</p>

<ul>
<li>Il s'agit de valeurs à virgule flottante que vous pouvez définir comme nouvelles durées de mémoire tampon minimale et maximale.</li>
<li>Si les valeurs sont trop petites, la lecture peut se bloquer dans des conditions de réseau irrégulières.</li>
<li>Si les valeurs sont trop grandes, le <code>AVPplayer</code> peut mettre en mémoire tampon des données qui ne sont jamais consultées.</li>
<li>Il est important de tester en fonction de vos cas d'utilisation attendus.</li>
<li>Les valeurs sont spécifiées en secondes et doivent être supérieures ou égales à 1,0. (Zéro est une valeur spéciale dans le <code>AVPlayerItem</code> qui raconte le <code>AVPplayer</code> pour déterminer sa propre taille de tampon.</li>
</ul>


<h2>Désactivation de l'optimisation de la mémoire tampon</h2>

<p>Si vous ne voulez pas d'optimisation de tampon active dans votre session de lecture en cours, vous pouvez utiliser la même technique, mais définir la méthode d'optimisation sur &ldquo;Rien&rdquo; comme suit:</p>

<pre><code>// Créer un dictionnaire mutable pour contenir de nouvelles valeurs NSMutableDictionary *options = self.playbackController.options.mutableCopy; // Définir de nouvelles valeurs dans les options du dictionnaire[kBCOVBufferOptimizerMethodKey] = @(BCOVBufferOptimizerMethodNone); // Définir un nouveau dictionnaire dans votre contrôleur de lecture self.playbackController.options = options; </code></pre>

<p>Avec la méthode définie sur "Aucun", iOS conservera le contrôle total de la taille du tampon de transfert.</p>

<h2>Implémentation de votre propre méthode d'optimisation de tampon</h2>

<p>Si vous souhaitez définir votre propre taille de mémoire tampon pour la lecture, désactivez d'abord l'optimisation de la mémoire tampon comme décrit dans la section précédente. Ensuite, vous pouvez mettre en œuvre ce qui suit <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a> méthode déléguée :</p>

<pre><code>- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)contrôleur didAdvanceToPlaybackSession:(id&lt;BCOVPlaybackSession&gt;)session { // Make sure the property exists on the current AVPlayerItem. if ([session.player.currentItem respondsToSelector:NSSelectorFromString(@"preferredForwardBufferDuration")]) { // Set your preferredForwardBufferDuration value here. session.player.currentItem.preferredForwardBufferDuration = newPreferredForwardBufferDurationValue; } } </code></pre>

<p>Si vous souhaitez modifier la taille de la mémoire tampon de manière dynamique au fil du temps, vous pouvez définir <code>session.player.currentItem.preferredForwardBufferDuration</code> dans le <a href="Protocols/BCOVPlaybackController.html"><code>Contrôleur de lecture BCOV</code></a>&rsquo;s progresse la méthode déléguée de la même manière :</p>

<pre><code>- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)contrôleur playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didProgressTo:(NSTimeInterval)progress { // Make sure the property exists on the current AVPlayerItem. if ([session.player.currentItem respondsToSelector:NSSelectorFromString(@"preferredForwardBufferDuration")]) { // Set preferredForwardBufferDuration based on your own logic here session.player.currentItem.preferredForwardBufferDuration = newPreferredForwardBufferDurationValue; } } </code></pre>

<p>Noter: Apple a spécifiquement mis &ldquo;préféré&rdquo; dans <code>préféréForwardBufferDuration</code> parce que vous pouvez définir n'importe quelle valeur, mais en général, le <code>AVPplayer</code> le joueur ne l'utilisera qu'à titre indicatif. Gardez également à l'esprit que le mettre à zéro renvoie le contrôle total de la taille de la mémoire tampon au <code>AVPplayer</code>.</p>

<h1>Utiliser un AVPlayerViewController avec un <a href="Protocols/BCOVPlaybackController.html">Contrôleur de lecture BCOV</a> <a name="AVPlayerViewController"></a></h1>

<h2>Aperçu</h2>

<p>Vous pouvez utiliser AVPlayerViewController au lieu de AVPlayerLayer utilisé par le <a href="Protocols/BCOVPlaybackSession.html">BCOVSession de lecture</a> classer. L'utilisation d'AVPlayerViewController permet au lecteur d'utiliser les commandes natives du lecteur iOS et tvOS, mais il existe des limitations à cette approche (voir ci-dessous).</p>

<p>Pour utiliser l'AVPlayerViewController, vous pouvez définir un <a href="Protocols/BCOVPlaybackController.html">Contrôleur de lecture BCOV</a> propriété de dictionnaire appelée <code>kBCOVAVPlayerViewControllerCompatibilityKey</code>:</p>

<pre><code>BCOVPlayerSDKManager *sdkManager = [BCOVPlayerSDKManagersharedManager] ; idBCOVPlaybackController playController; NSMutableDictionary *mutableOptions = self.playbackController.options.mutableCopy; // Pour utiliser AVPlayerViewController mutableOptions[kBCOVAVPlayerViewControllerCompatibilityKey] = @YES; // Pour utiliser l'AVPlayerLayer de BCOVPlaybackSession // mutableOptions[kBCOVAVPlayerViewControllerCompatibilityKey] = @NO; self.playbackController.options = mutableOptions; </code></pre>

<p>La valeur par défaut de kBCOVAVPlayerViewControllerCompatibilityKey est @NO, ce qui signifie qu'un <a href="Protocols/BCOVPlaybackController.html">Contrôleur de lecture BCOV</a> créé sans cette propriété de dictionnaire explicitement définie utilisera le BCOVPlaybackSession&rsquo;s AVPlayerLayer par défaut.</p>

<h2>Exemples de projets</h2>

<p>Nous avons des exemples de projets démontrant l'utilisation d'AVPlayerViewController avec le Brightcove iOS SDK. Vous pouvez trouver le <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/NativeControls">Exemple de projet iOS ici</a> et le <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/IMA/NativeControlsIMAPlayer_tvOS">Exemple de projet tvOS ici</a>.</p>

<h2>Limitations à l'utilisation d'AVPlayerViewController</h2>

<p><strong>Publicité:</strong></p>

<p>Les plug-ins publicitaires Brightcove IMA et FreeWheel sont compatibles avec AVPlayerViewController. Vous pouvez utiliser l'AVPlayerViewController&rsquo;s <code>contentOverlayView</code> pour la vue dans laquelle afficher les annonces.</p>

<p>Vous pouvez masquer/afficher l'AVPlayerViewController&rsquo;Contrôles de lecture avant et après la diffusion des publicités :</p>

<pre><code>- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)contrôleur playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didEnterAdSequence:(BCOVAdSequence *)adSequence { self.avpvc.showsPlaybackControls = NO; } - (void)playbackController:(id&lt;BCOVPlaybackController&gt;)contrôleur playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didExitAdSequence:(BCOVAdSequence *)adSequence { self.avpvc.showsPlaybackControls = YES; } </code></pre>

<p>Les plug-ins publicitaires Brightcove SSAI et Pulse ne sont actuellement pas compatibles avec AVPlayerViewController.</p>

<p><strong>Analytique:</strong></p>

<p>Lors de l'utilisation d'AVPlayerViewController, les événements video_engagement envoyés au serveur Brightcove Analytics rapporteront 0 pour player_width et player_height.</p>

<h1>Service d'autorisation de lecture <a name="PlaybackAuthorizationService"></a></h1>

<p>Si vous utilisez le service d'autorisation de lecture, vous devrez utiliser les méthodes du service de lecture qui vous permettent de transmettre un jeton d'autorisation.</p>

<pre><code>- (void)findPlaylistWithPlaylistID:(NSString *)playlistID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters complete:(void (^)(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error))completionHandler; - (void)findPlaylistWithReferenceID:(NSString *)referenceID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters complete:(void (^)(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error))completionHandler; - (void)findVideoWithVideoID:(NSString *)videoID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters complete:(void (^)(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error))completionHandler; - (void)findVideoWithReferenceID:(NSString *)referenceID authToken:(NSString *)authToken parameters:(NSDictionary *)parameters complete:(void (^)(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error))completionHandler; </code></pre>

<p><strong>Noter: Dans le cas des playlists, toutes les vidéos de la playlist doivent utiliser le même jeton. Dans une version ultérieure, il sera possible d'attribuer un jeton différent à chaque vidéo d'une playlist. Vous serez responsable du maintien du mappage entre l'identifiant vidéo et le jeton.</strong></p>

<h1>Assistance VoiceOver <a name="VoiceOver"></a></h1>

<p>VoiceOver est pris en charge par défaut pour les commandes de lecture. Par défaut, si VoiceOver est activé, la vue de contrôle BCOVPlayerUI ne se masquera pas automatiquement. Utilisation du geste d'activation VoiceOver en appuyant deux fois sur le contrôleur de lecture&rsquo;La vue s basculera la visibilité de la vue de contrôle. Il y a un associé <code>accessibilitéAstuce</code> qui est réglé sur le contrôleur de lecture&rsquo;vue. Les <code>accessibilitéLibellé</code> de chaque contrôle BCOVPlayerUI peut être personnalisé au sein de votre application.</p>

<p>Pour changer le <code>accessibilitéLibellé</code> valeurs de l'un des boutons de la vue de contrôle, vous devez définir un objet comme un <a href="Protocols/BCOVPUIButtonAccessibilityDelegate.html"><code>BCOVPUIBoutonAccessibilitéDélégué</code></a> comme ça:</p>

<pre><code>[self.playerView.controlsView setButtonsAccessibilityDelegate:self]; </code></pre>

<p>Vous devez alors faire en sorte que cet objet soit conforme à la <a href="Protocols/BCOVPUIButtonAccessibilityDelegate.html"><code>BCOVPUIBoutonAccessibilitéDélégué</code></a> protocole en mettant en place le <code> - (NSString *)accessibilityLabelForButton:(</code>BCOVPUIBouton<code> *)bouton isPrimaryState:(BOOL)isPrimaryState</code> méthode similaire à celle-ci :</p>

<pre><code>- (NSString *)accessibilityLabelForButton:(BCOVPUIButton *)button isPrimaryState:(BOOL)isPrimaryState { switch (button.tag) { case BCOVPUIViewTagButtonPlayback: return isPrimaryState ? NSLocalizedString(@"Start Playback", nil) : NSLocalizedString(@"Stop PLayback", nil); case BCOVPUIViewTagButtonScreenMode: return isPrimaryState ? NSLocalizedString(@"Enter Fullscreen", nil) : NSLocalizedString(@"Exit Fullscreen", nil); case BCOVPUIViewTagButtonJumpBack: return nil; case BCOVPUIViewTagButtonClosedCaption: return nil; case BCOVPUIViewTagButtonVideo360: return nil; case BCOVPUIViewTagButtonPreferredBitrate: return nil; default: return nil; } } </code></pre>

<p>Si un <code>néant</code> value est renvoyé, la valeur par défaut sera utilisée.</p>

<p>Réglage de la <code>accessibilitéAstuce</code> sur le contrôleur de lecture peut être fait comme ceci :</p>

<pre><code>self.playbackController.view.accessibilityHint = @"Appuyez deux fois pour afficher ou masquer les commandes"; </code></pre>

<p>De même, vous pouvez définir le <code>accessibilitéLibellé</code> sur les étiquettes d'heure et de durée actuelles, ainsi que le curseur de progression, comme ceci :</p>

<pre><code>self.playerView.controlsView.durationLabel.accessibilityLabelPrefix = @"Temps total"; self.playerView.controlsView.currentTimeLabel.accessibilityLabelPrefix = @"Current Time"; self.playerView.controlsView.progressSlider.accessibilityLabel = @"Timeline"; </code></pre>

<h1>Livraison en Chine <a name="ChinaDelivery"></a></h1>

<p>Pour définir un domaine proxy pour les services de lecture, les métriques et les serveurs d'analyse en Chine, définissez le <code>chineProxyDomain</code> propriété de la <a href="Classes/BCOVGlobalConfiguration.html"><code>BCOVGlobalConfiguration</code></a> singleton en un nom de domaine complet. Par exemple:</p>

<pre><code>BCOVGlobalConfiguration.sharedConfig.chinaProxyDomain = @"hôte.mondomaine.com"; </code></pre>

<p>Assurez-vous de définir le nom de domaine proxy avant d'utiliser tout autre service du kit de développement logiciel Native Player. Se référer au <a href="https://docs.brightcove.com/ios-sdk/Classes/BCOVGlobalConfiguration.html#//api/name/chinaProxyDomain"><em>Référence de classe BCOVGlobalConfiguration</em></a> pour les détails.</p>

<h1>Configuration d'AVAudioSession <a name="AVAudioSessionConfig"></a></h1>

<p>Selon les performances de votre application en matière de lecture audio, vous pouvez configurer AVAudioSession en fonction de vos besoins spécifiques. Par exemple, si vous souhaitez prendre en charge AirPlay 2 et plusieurs itinéraires audio, consultez le <a href="#AirPlay">AirPlay</a> section de ce fichier README.</p>

<p>Une AVAudioSession basique peut être configurée comme ceci :</p>

<pre><code>// Obj-C NSError *categoryError = nil; // voir https://developer.apple.com/documentation/avfoundation/avaudiosessioncategoryplayback BOOL success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;categoryError]; si (!succès) { // Handle error } </code></pre>

<pre><code>// Swift var categoryError :NSError? succès var : Bool faire { // see https://developer.apple.com/documentation/avfoundation/avaudiosessioncategoryplayback try AVAudioSession.sharedInstance().setCategory(.playback) success = true } catch let error as NSError { categoryError = error success = false } si !succès { // Handle error } </code></pre>

<p>Cette configuration peut généralement être effectuée dans votre AppDelegate&rsquo;s <code>application:didFinishLaunchingWithOptions :</code> méthode. Il peut y avoir des situations où vous avez besoin d'une configuration AVAudioSession plus sophistiquée, par exemple si vous souhaitez permettre à l'audio d'autres applications d'être entendu lorsque le son de votre application est coupé. Dans cette situation, vous pouvez configurer l'AVAudioSession dans le contrôleur de vue qui a accès à votre AVPlayer actuel. Par exemple:</p>

<pre><code>// Fonction Swift setUpAudioSession() { var categoryError :NSError? var success: Bool do { if let currentPlayer = currentPlayer { // If the player is muted, then allow mixing. // Ensure other apps can have their background audio // active when this app is in foreground if currentPlayer.isMuted { try AVAudioSession.sharedInstance().setCategory(.playback, options: .mixWithOthers) } autre { try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0)) } } autre { try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0)) } success = true } catch let error as NSError { categoryError = error success = false } si !succès { print("AppDelegate Debug - Error setting AVAudioSession category. Because of this, there may be no sound. \(categoryError!)") } } </code></pre>

<pre><code>// Objc-C - (void)setUpAudioSession { NSError *categoryError = nil; BOOL success; // If the player is muted, then allow mixing. // Ensure other apps can have their background audio // active when this app is in foreground if (self.currentPlayer.isMuted) { success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionMixWithOthers error:&amp;categoryError]; } autre { success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:0 error:&amp;categoryError]; } si (!succès) { NSLog(@"AppDelegate Debug - Error setting AVAudioSession category. Because of this, there may be no sound. `%@`", categoryError); } } </code></pre>

<p>Un exemple de code peut être trouvé dans notre <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/VideoCloudBasicPlayer">VideoCloudBasicPlayer</a> exemple de projet.</p>

<p>Vous pouvez en savoir plus sur AVAudioSession <a href="https://developer.apple.com/documentation/avfoundation/avaudiosession">ici</a>.</p>

<h1>Questions fréquemment posées <a name="FAQ"></a></h1>

<p><strong>Mon contenu a gagné&rsquo;t charger. Existe-t-il un moyen simple de tester si l'URL pointe vers une vidéo valide ?</strong></p>

<p>Si le contenu est conditionné au format MP4, vous pouvez coller l'URL directement dans la plupart des navigateurs Web et la vidéo devrait être lue (ou téléchargée sur votre système de fichiers, où vous pouvez la lire localement). Si le contenu est conditionné en HLS, vous pouvez utiliser QuickTime Player pour le tester : sélectionnez <code>Fichier -&gt; Ouvrir l'emplacement…</code> et coller dans le <code>.m3u8</code> URL de la liste de lecture et la vidéo devrait être lue.</p>

<p><strong>J'entends la piste audio en cours de lecture, mais la vidéo se fige sporadiquement pendant quelques secondes. Quoi&rsquo;se passe-t-il ?</strong></p>

<p>Il s'agit d'un symptôme courant d'avoir appelé une méthode UIKit ou AVFoundation de thread principal uniquement à partir d'un thread non principal. Les méthodes déléguées sur <a href="Protocols/BCOVPlaybackControllerDelegate.html"><code>BCOVPlaybackControllerDélégué</code></a> sont toujours appelés sur le thread principal.</p>

<p><strong>Pourquoi est-ce que je vois un message dans le journal indiquant qu'aucune source n'a été trouvée ?</strong></p>

<p>Ce message indique que la politique de sélection de source par défaut peut&rsquo;t figure quelle source choisir. La politique par défaut sélectionne la première source dont <code>méthode de livraison</code> est <code>kBCOVSourceLivraisonHLS</code> (&ldquo;HLS&rdquo;). Si aucune source HLS n'est trouvée, son comportement de repli sélectionnera la première source dont <code>méthode de livraison</code> est <code>kBCOVSourceLivraisonMP4</code> (&ldquo;MP4&rdquo;). Si aucune source avec un <code>méthode de livraison</code> de &ldquo;HLS&rdquo; ou &ldquo;MP4&rdquo; existe sur la vidéo, la politique sélectionnera la vidéo&rsquo;s première source (indépendamment de <code>méthode de livraison</code>). Si vous êtes&rsquo;t content de sa sélection, vous pouvez utiliser <a href="Classes/BCOVPlayerSDKManager.html#//api/name/createBasicSessionProviderWithOptions:"><code>[BCOVPlayerSDKManager createBasicSessionProviderWithOptions :]</code></a> et passer dans une instance de <a href="Classes/BCOVBasicSessionProviderOptions.html"><code>BCOVBasicSessionProviderOptions</code></a> avec une coutume <code>sourceSélectionPolitique</code> ensemble de propriétés. Lors de la création manuelle de vidéos et de sources, assurez-vous que les sources sont créées avec les <code>méthode de livraison</code>.</p>

<p><strong><a href="https://developer.apple.com/Library/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/AudioGuidelinesByAppType/AudioGuidelinesByAppType.html">Apple recommande</a> que les applications qui lisent la vidéo doivent toujours lire l'audio même lorsque l'appareil est en sourdine. Pourquoi ne&rsquo;t le Brightcove Player SDK pour iOS respecte-t-il ces directives ?</strong></p>

<p>L'API qui contrôle si une application émet de l'audio dans les applications iOS est la <a href="https://developer.apple.com/Library/ios/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875-CH1-SW1">API AVAudioSession</a>. Une session audio est globale à une application, ce qui signifie que sa configuration affecte à la fois les sons émis par les AVPlayers créés par le Player SDK, ainsi que les autres sons qu'une application peut produire. Étant donné que le SDK du lecteur ne peut pas savoir comment l'application souhaite que la session audio soit configurée pour ces autres sons, il ne&rsquo;n'affecte pas du tout la session audio. Cela signifie qu'à moins que vous ne configuriez explicitement votre application&rsquo;Dans le cas contraire, vous héritez du comportement par défaut consistant à supprimer tout ou partie de l'audio lorsque le périphérique est coupé, y compris l'audio émis par les AVPlayers. Pour se conformer à Apple&rsquo;s recommandations concernant la lecture audio, vous (le développeur de l'application) devez configurer la session audio en fonction de votre application&rsquo;s besoins spécifiques.</p>

<p>Voir notre <a href="#AVAudioSessionConfig">Configuration d'AVAudioSession</a> dans ce fichier README pour plus d'informations.</p>

<h1>Soutien <a name="Support"></a></h1>

<p>Si vous avez des questions, avez besoin d'aide ou souhaitez faire part de vos commentaires, veuillez utiliser le <a href="https://supportportal.brightcove.com/s/login/">Portail d'assistance</a> ou contactez votre gestionnaire de compte. Pour recevoir une notification des nouvelles versions du logiciel SDK, abonnez-vous aux SDK Brightcove Native Player <a href="https://groups.google.com/g/brightcove-native-player-sdks">Groupe Google</a>.</p>
						
						
					</div>
					

					<div class="index-container">
						

						
						<div class="index-column">
							<h2 class="index-title">Références de classe</h2>
							<ul>
								
								<li>BCOVAd<a href="Classes/BCOVAd.html"></a></li>
								
								<li><a href="Classes/BCOVAdSequence.html">BCOVAdSéquence</a></li>
								
								<li>BCOVBasicSessionProvider<a href="Classes/BCOVBasicSessionProvider.html"></a></li>
								
								<li>BCOVBasicSessionProviderOptions<a href="Classes/BCOVBasicSessionProviderOptions.html"></a></li>
								
								<li><a href="Classes/BCOVBasicSourceSelectionPolicy.html">BCOVBasicSourceSelectionPolitique</a></li>
								
								<li>BCOVCuePoint<a href="Classes/BCOVCuePoint.html"></a></li>
								
								<li>BCOVCuePointCollection<a href="Classes/BCOVCuePointCollection.html"></a></li>
								
								<li>BCOVCuePointProgressPolicy<a href="Classes/BCOVCuePointProgressPolicy.html"></a></li>
								
								<li>BCOVCuePointProgressPolicyResult<a href="Classes/BCOVCuePointProgressPolicyResult.html"></a></li>
								
								<li>BCOVFPSBrightcoveAuthProxy<a href="Classes/BCOVFPSBrightcoveAuthProxy.html"></a></li>
								
								<li>BCOVFairPlayManager<a href="Classes/BCOVFairPlayManager.html"></a></li>
								
								<li>BCOVGlobalConfiguration<a href="Classes/BCOVGlobalConfiguration.html"></a></li>
								
								<li><a href="Classes/BCOVOfflineVideoManager.html">BCOVHors ligneVideoManager</a></li>
								
								<li><a href="Classes/BCOVOfflineVideoStatus.html">BCOVHors ligneVideoStatus</a></li>
								
								<li>BCOVPUIAdControlView<a href="Classes/BCOVPUIAdControlView.html"></a></li>
								
								<li>BCOVPUIBasicControlView<a href="Classes/BCOVPUIBasicControlView.html"></a></li>
								
								<li><a href="Classes/BCOVPUIButton.html">BCOVPUIBouton</a></li>
								
								<li><a href="Classes/BCOVPUICommon.html">BCOVPUICommun</a></li>
								
								<li>BCOVPUIControlLayout<a href="Classes/BCOVPUIControlLayout.html"></a></li>
								
								<li>BCOVPUILayoutView<a href="Classes/BCOVPUILayoutView.html"></a></li>
								
								<li>BCOVPUIPlayerView<a href="Classes/BCOVPUIPlayerView.html"></a></li>
								
								<li>BCOVPUIPlayerViewOptions<a href="Classes/BCOVPUIPlayerViewOptions.html"></a></li>
								
								<li><a href="Classes/BCOVPUISlider.html">BCOVPUIScurseur</a></li>
								
								<li>BCOVPlaybackService<a href="Classes/BCOVPlaybackService.html"></a></li>
								
								<li>BCOVPlaybackServiceRequestFactory<a href="Classes/BCOVPlaybackServiceRequestFactory.html"></a></li>
								
								<li>BCOVPlaybackSessionLifecycleEvent<a href="Classes/BCOVPlaybackSessionLifecycleEvent.html"></a></li>
								
								<li>BCOVPlayerSDKManager<a href="Classes/BCOVPlayerSDKManager.html"></a></li>
								
								<li>BCOVPlaylist<a href="Classes/BCOVPlaylist.html"></a></li>
								
								<li>BCOVPreferredBitrateConfig<a href="Classes/BCOVPreferredBitrateConfig.html"></a></li>
								
								<li>BCOVSessionProviderExtension<a href="Classes/BCOVSessionProviderExtension.html"></a></li>
								
								<li><a href="Classes/BCOVSource.html">Source BCOV</a></li>
								
								<li>BCOVTVAudioTabBarItemView<a href="Classes/BCOVTVAudioTabBarItemView.html"></a></li>
								
								<li><a href="Classes/BCOVTVCommon.html">BCOVTVCommun</a></li>
								
								<li>BCOVTVControlsView<a href="Classes/BCOVTVControlsView.html"></a></li>
								
								<li>BCOVTVInfoTabBarItemView<a href="Classes/BCOVTVInfoTabBarItemView.html"></a></li>
								
								<li>BCOVTVPlayerView<a href="Classes/BCOVTVPlayerView.html"></a></li>
								
								<li>BCOVTVPlayerViewOptions<a href="Classes/BCOVTVPlayerViewOptions.html"></a></li>
								
								<li>BCOVTVProgressView<a href="Classes/BCOVTVProgressView.html"></a></li>
								
								<li><a href="Classes/BCOVTVSettingsView.html">BCOVTVParamètresAfficher</a></li>
								
								<li><a href="Classes/BCOVTVSubtitlesTabBarItemView.html">BCOVTVSous-titresTabBarItemView</a></li>
								
								<li>BCOVTVTabBarItemView<a href="Classes/BCOVTVTabBarItemView.html"></a></li>
								
								<li>BCOVUILabel<a href="Classes/BCOVUILabel.html"></a></li>
								
								<li><a href="Classes/BCOVVideo.html">BCOVVidéo</a></li>
								
								<li><a href="Classes/BCOVVideo360ViewProjection.html">BCOVVidéo360VoirProjection</a></li>
								
							</ul>
						</div>
						

						
						<div class="index-column">
							
							<h2 class="index-title">Références de protocole</h2>
							<ul>
								
								<li><a href="Protocols/BCOVComponent.html">Composant BCOV</a></li>
								
								<li>BCOVComponentIdentity<a href="Protocols/BCOVComponentIdentity.html"></a></li>
								
								<li>BCOVCuePoint<a href="Protocols/BCOVCuePoint.html"></a></li>
								
								<li><a href="Protocols/BCOVFPSAuthorizationProxy.html">BCOVFPSAthorizationProxy</a></li>
								
								<li>BCOVMutableAnalytics<a href="Protocols/BCOVMutableAnalytics.html"></a></li>
								
								<li>BCOVMutableCuePoint<a href="Protocols/BCOVMutableCuePoint.html"></a></li>
								
								<li>BCOVMutablePlaylist<a href="Protocols/BCOVMutablePlaylist.html"></a></li>
								
								<li>BCOVMutableSource<a href="Protocols/BCOVMutableSource.html"></a></li>
								
								<li><a href="Protocols/BCOVMutableVideo.html">BCOVMutableVidéo</a></li>
								
								<li><a href="Protocols/BCOVOfflineVideoManagerDelegate.html">BCOVHors ligneVideoManagerDélégué</a></li>
								
								<li><a href="Protocols/BCOVPUIButtonAccessibilityDelegate.html">BCOVPUIBoutonAccessibilitéDélégué</a></li>
								
								<li>BCOVPUIPlayerViewDelegate<a href="Protocols/BCOVPUIPlayerViewDelegate.html"></a></li>
								
								<li><a href="Protocols/BCOVPlaybackController.html">Contrôleur de lecture BCOV</a></li>
								
								<li><a href="Protocols/BCOVPlaybackControllerAdsDelegate.html">BCOVPlaybackControllerAnnoncesDélégué</a></li>
								
								<li><a href="Protocols/BCOVPlaybackControllerBasicDelegate.html">BCOVPlaybackControllerBasicDélégué</a></li>
								
								<li><a href="Protocols/BCOVPlaybackControllerDelegate.html">BCOVPlaybackControllerDélégué</a></li>
								
								<li><a href="Protocols/BCOVPlaybackSession.html">BCOVSession de lecture</a></li>
								
								<li><a href="Protocols/BCOVPlaybackSessionAdsConsumer.html">BCOVLectureSessionAnnoncesConsommateur</a></li>
								
								<li>BCOVPlaybackSessionBasicConsumer<a href="Protocols/BCOVPlaybackSessionBasicConsumer.html"></a></li>
								
								<li><a href="Protocols/BCOVPlaybackSessionConsumer.html">BCOVPlaybackSessionConsommateur</a></li>
								
								<li>BCOVPlaybackSessionProvider<a href="Protocols/BCOVPlaybackSessionProvider.html"></a></li>
								
								<li>BCOVPlaylist<a href="Protocols/BCOVPlaylist.html"></a></li>
								
								<li><a href="Protocols/BCOVSource.html">Source BCOV</a></li>
								
								<li><a href="Protocols/BCOVTVPlayerViewDelegate.html">BCOVTVPlayerVoirDélégué</a></li>
								
								<li><a href="Protocols/BCOVVideo.html">BCOVVidéo</a></li>
								
							</ul>
							

							
							<h2 class="index-title">Références constantes</h2>
							<ul>
								
									<li>BCOVBufferOptimizerMethod<a href="Constants/BCOVBufferOptimizerMethod.html"></a></li>
								
									<li><a href="Constants/BCOVEconomics.html">BCOVEéconomie</a></li>
								
									<li><a href="Constants/BCOVOfflineVideoDownloadState.html">BCOVHors ligneVidéoTéléchargerÉtat</a></li>
								
									<li>BCOVPUIButtonIcon<a href="Constants/BCOVPUIButtonIcon.html"></a></li>
								
									<li><a href="Constants/BCOVPUILearnMoreButtonBrowserStyle.html">BCOVPUIEn savoir plusBoutonBrowserStyle</a></li>
								
									<li><a href="Constants/BCOVPUIScreenMode.html">BCOVPUISscreenMode</a></li>
								
									<li><a href="Constants/BCOVPUIVideo360NavigationMethod.html">BCOVPUIVideo360Méthode de navigation</a></li>
								
									<li><a href="Constants/BCOVPUIViewTag.html">BCOVPUIVoirTag</a></li>
								
									<li><a href="Constants/BCOVPlaybackServiceErrorCode.html">Code d'erreur BCOVPlaybackService</a></li>
								
									<li>BCOVProgressPolicyCuePointsToProcess<a href="Constants/BCOVProgressPolicyCuePointsToProcess.html"></a></li>
								
									<li>BCOVProgressPolicyResumePosition<a href="Constants/BCOVProgressPolicyResumePosition.html"></a></li>
								
									<li>BCOVTVIconType<a href="Constants/BCOVTVIconType.html"></a></li>
								
									<li>BCOVTVPlayerType<a href="Constants/BCOVTVPlayerType.html"></a></li>
								
									<li><a href="Constants/BCOVTVShowViewType.html">BCOVTVAfficherType de vue</a></li>
								
									<li><a href="Constants/BCOVVideo360ProjectionStyle.html">BCOVVidéo360ProjectionStyle</a></li>
								
									<li><a href="Constants/BCOVVideo360SourceFormat.html">BCOVVideo360FormatSource</a></li>
								
									<li><a href="Constants/BCOVVideoType.html">BCOVType de vidéo</a></li>
								
							</ul>
							

							
							<h2 class="index-title">Références de catégorie</h2>
							<ul>
								
								<li><a href="Categories/NSDictionary-BCOVURLSupport.html">NSDictionary (BCOVURLSupport)</a></li>
								
							</ul>
							
						</div>
						
					</div>

					<footer>
						<div class="footer-copyright">
							
							<p class="copyright">droits d'auteur &copy; 2021 Brightcove. Tous les droits sont réservés. Mis à jour: 2021-07-08</p>
							
							
							<p class="generator">Généré par <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
							
						</div>
					</footer>
				</main>
			</div>
		</div>
	</article>

	<script src="js/script.js"></script>
</body>
</html>
